// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestActionDefinition_EncodeDecode(t *testing.T) {
	var typ ActionDefinition
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionDefinition
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionDefinitionSimpleNotification_EncodeDecode(t *testing.T) {
	var typ ActionDefinitionSimpleNotification
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionDefinitionSimpleNotification
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionDefinitionSimpleNotificationActionType_EncodeDecode(t *testing.T) {
	var typ ActionDefinitionSimpleNotificationActionType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionDefinitionSimpleNotificationActionType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionDefinitionSum_EncodeDecode(t *testing.T) {
	var typ ActionDefinitionSum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionDefinitionSum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionDefinitionWorkflows_EncodeDecode(t *testing.T) {
	var typ ActionDefinitionWorkflows
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionDefinitionWorkflows
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActionDefinitionWorkflowsActionType_EncodeDecode(t *testing.T) {
	var typ ActionDefinitionWorkflowsActionType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActionDefinitionWorkflowsActionType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivationCreateInput_EncodeDecode(t *testing.T) {
	var typ ActivationCreateInput
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivationCreateInput
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivationOutput_EncodeDecode(t *testing.T) {
	var typ ActivationOutput
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivationOutput
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestActivationUpdateInput_EncodeDecode(t *testing.T) {
	var typ ActivationUpdateInput
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ActivationUpdateInput
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddonDatalakeNoPublicAccess_EncodeDecode(t *testing.T) {
	var typ AddonDatalakeNoPublicAccess
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddonDatalakeNoPublicAccess
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddonDatalakeNoPublicAccessEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ AddonDatalakeNoPublicAccessEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddonDatalakeNoPublicAccessEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddonDwhNoPublicAccess_EncodeDecode(t *testing.T) {
	var typ AddonDwhNoPublicAccess
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddonDwhNoPublicAccess
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddonDwhNoPublicAccessEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ AddonDwhNoPublicAccessEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddonDwhNoPublicAccessEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddonThreatDetectionEnabled_EncodeDecode(t *testing.T) {
	var typ AddonThreatDetectionEnabled
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddonThreatDetectionEnabled
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddonThreatDetectionEnabledEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ AddonThreatDetectionEnabledEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddonThreatDetectionEnabledEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddonThreatDetections_EncodeDecode(t *testing.T) {
	var typ AddonThreatDetections
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddonThreatDetections
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddonThreatDetectionsEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ AddonThreatDetectionsEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddonThreatDetectionsEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddonVulnerabilityDetections_EncodeDecode(t *testing.T) {
	var typ AddonVulnerabilityDetections
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddonVulnerabilityDetections
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAddonVulnerabilityDetectionsEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ AddonVulnerabilityDetectionsEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AddonVulnerabilityDetectionsEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionID_EncodeDecode(t *testing.T) {
	var typ AutomatedActionID
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionID
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionInput_EncodeDecode(t *testing.T) {
	var typ AutomatedActionInput
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionInput
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionOutput_EncodeDecode(t *testing.T) {
	var typ AutomatedActionOutput
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionOutput
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsCreateApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsCreateApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsCreateApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsCreateApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsCreateApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsCreateApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsCreateApplicationJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsCreateApplicationJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsCreateApplicationJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsCreateApplicationProblemJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsCreateApplicationProblemJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsCreateApplicationProblemJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsCreateApplicationProblemJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsCreateApplicationProblemJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsCreateApplicationProblemJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsCreateApplicationProblemJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsCreateApplicationProblemJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsCreateApplicationProblemJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsDeleteApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsDeleteApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsDeleteApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsDeleteApplicationJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsDeleteApplicationJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsDeleteApplicationJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsDeleteApplicationProblemJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsDeleteApplicationProblemJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsDeleteApplicationProblemJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsDeleteApplicationProblemJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsDeleteApplicationProblemJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsDeleteApplicationProblemJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsListApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsListApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsListApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsListApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsListApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsListApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsListApplicationJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsListApplicationJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsListApplicationJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsListApplicationProblemJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsListApplicationProblemJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsListApplicationProblemJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsListApplicationProblemJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsListApplicationProblemJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsListApplicationProblemJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsListApplicationProblemJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsListApplicationProblemJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsListApplicationProblemJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsListOK_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsListOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsListOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsReadApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsReadApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsReadApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsReadApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsReadApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsReadApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsReadApplicationJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsReadApplicationJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsReadApplicationJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsReadApplicationProblemJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsReadApplicationProblemJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsReadApplicationProblemJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsReadApplicationProblemJSONNotFound_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsReadApplicationProblemJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsReadApplicationProblemJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsReadApplicationProblemJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsReadApplicationProblemJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsReadApplicationProblemJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsUpdateApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsUpdateApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsUpdateApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsUpdateApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsUpdateApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsUpdateApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsUpdateApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsUpdateApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsUpdateApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsUpdateApplicationJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsUpdateApplicationJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsUpdateApplicationJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsUpdateApplicationProblemJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsUpdateApplicationProblemJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsUpdateApplicationProblemJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsUpdateApplicationProblemJSONForbidden_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsUpdateApplicationProblemJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsUpdateApplicationProblemJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsUpdateApplicationProblemJSONNotFound_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsUpdateApplicationProblemJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsUpdateApplicationProblemJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAutomatedActionsUpdateApplicationProblemJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ AutomatedActionsUpdateApplicationProblemJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AutomatedActionsUpdateApplicationProblemJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBadRequest_EncodeDecode(t *testing.T) {
	var typ BadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBadRequestDetail_EncodeDecode(t *testing.T) {
	var typ BadRequestDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BadRequestDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestBadRequestStatus_EncodeDecode(t *testing.T) {
	var typ BadRequestStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 BadRequestStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConflict_EncodeDecode(t *testing.T) {
	var typ Conflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Conflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConflictDetail_EncodeDecode(t *testing.T) {
	var typ ConflictDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConflictDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestConflictStatus_EncodeDecode(t *testing.T) {
	var typ ConflictStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ConflictStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDbaEncryptionEnabled_EncodeDecode(t *testing.T) {
	var typ DbaEncryptionEnabled
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DbaEncryptionEnabled
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDbaEncryptionEnabledEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ DbaEncryptionEnabledEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DbaEncryptionEnabledEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDbaNoPublicIP_EncodeDecode(t *testing.T) {
	var typ DbaNoPublicIP
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DbaNoPublicIP
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDbaNoPublicIPEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ DbaNoPublicIPEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DbaNoPublicIPEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDiskEncryptionEnabled_EncodeDecode(t *testing.T) {
	var typ DiskEncryptionEnabled
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DiskEncryptionEnabled
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDiskEncryptionEnabledEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ DiskEncryptionEnabledEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 DiskEncryptionEnabledEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestELBLoggingEnabled_EncodeDecode(t *testing.T) {
	var typ ELBLoggingEnabled
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ELBLoggingEnabled
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestELBLoggingEnabledEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ ELBLoggingEnabledEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ELBLoggingEnabledEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRule_EncodeDecode(t *testing.T) {
	var typ EvaluationRule
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRule
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRuleInput_EncodeDecode(t *testing.T) {
	var typ EvaluationRuleInput
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRuleInput
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRuleParametersEvaluationTarget_EncodeDecode(t *testing.T) {
	var typ EvaluationRuleParametersEvaluationTarget
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRuleParametersEvaluationTarget
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRuleParametersObjectStorageEvaluationTarget_EncodeDecode(t *testing.T) {
	var typ EvaluationRuleParametersObjectStorageEvaluationTarget
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRuleParametersObjectStorageEvaluationTarget
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRuleParametersZonedEvaluationTarget_EncodeDecode(t *testing.T) {
	var typ EvaluationRuleParametersZonedEvaluationTarget
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRuleParametersZonedEvaluationTarget
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRuleUnion_EncodeDecode(t *testing.T) {
	var typ EvaluationRuleUnion
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRuleUnion
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRuleUnionSum_EncodeDecode(t *testing.T) {
	var typ EvaluationRuleUnionSum
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRuleUnionSum
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesListApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesListApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesListApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesListApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesListApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesListApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesListApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesListApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesListApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesListApplicationJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesListApplicationJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesListApplicationJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesListApplicationProblemJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesListApplicationProblemJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesListApplicationProblemJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesListApplicationProblemJSONForbidden_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesListApplicationProblemJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesListApplicationProblemJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesListApplicationProblemJSONNotFound_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesListApplicationProblemJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesListApplicationProblemJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesListApplicationProblemJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesListApplicationProblemJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesListApplicationProblemJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesListOK_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesListOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesListOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesReadApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesReadApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesReadApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesReadApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesReadApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesReadApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesReadApplicationJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesReadApplicationJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesReadApplicationJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesReadApplicationProblemJSONForbidden_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesReadApplicationProblemJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesReadApplicationProblemJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesReadApplicationProblemJSONNotFound_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesReadApplicationProblemJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesReadApplicationProblemJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesReadApplicationProblemJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesReadApplicationProblemJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesReadApplicationProblemJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesUpdateApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesUpdateApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesUpdateApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesUpdateApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesUpdateApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesUpdateApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesUpdateApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesUpdateApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesUpdateApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesUpdateApplicationJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesUpdateApplicationJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesUpdateApplicationJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesUpdateApplicationProblemJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesUpdateApplicationProblemJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesUpdateApplicationProblemJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesUpdateApplicationProblemJSONForbidden_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesUpdateApplicationProblemJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesUpdateApplicationProblemJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesUpdateApplicationProblemJSONNotFound_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesUpdateApplicationProblemJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesUpdateApplicationProblemJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvaluationRulesUpdateApplicationProblemJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ EvaluationRulesUpdateApplicationProblemJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EvaluationRulesUpdateApplicationProblemJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestForbidden_EncodeDecode(t *testing.T) {
	var typ Forbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Forbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestForbiddenDetail_EncodeDecode(t *testing.T) {
	var typ ForbiddenDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ForbiddenDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestForbiddenStatus_EncodeDecode(t *testing.T) {
	var typ ForbiddenStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ForbiddenStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIAMMemberOperationDetected_EncodeDecode(t *testing.T) {
	var typ IAMMemberOperationDetected
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IAMMemberOperationDetected
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestIAMMemberOperationDetectedEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ IAMMemberOperationDetectedEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 IAMMemberOperationDetectedEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNoSQLEncryptionEnabled_EncodeDecode(t *testing.T) {
	var typ NoSQLEncryptionEnabled
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NoSQLEncryptionEnabled
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNoSQLEncryptionEnabledEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ NoSQLEncryptionEnabledEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NoSQLEncryptionEnabledEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNotFound_EncodeDecode(t *testing.T) {
	var typ NotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNotFoundDetail_EncodeDecode(t *testing.T) {
	var typ NotFoundDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NotFoundDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestNotFoundStatus_EncodeDecode(t *testing.T) {
	var typ NotFoundStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 NotFoundStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestObjectStorageBucketACLChanged_EncodeDecode(t *testing.T) {
	var typ ObjectStorageBucketACLChanged
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ObjectStorageBucketACLChanged
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestObjectStorageBucketACLChangedEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ ObjectStorageBucketACLChangedEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ObjectStorageBucketACLChangedEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestObjectStorageBucketEncryptionEnabled_EncodeDecode(t *testing.T) {
	var typ ObjectStorageBucketEncryptionEnabled
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ObjectStorageBucketEncryptionEnabled
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestObjectStorageBucketEncryptionEnabledEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ ObjectStorageBucketEncryptionEnabledEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ObjectStorageBucketEncryptionEnabledEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationCreateApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ ProjectActivationCreateApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationCreateApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationCreateApplicationJSONConflict_EncodeDecode(t *testing.T) {
	var typ ProjectActivationCreateApplicationJSONConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationCreateApplicationJSONConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationCreateApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectActivationCreateApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationCreateApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationCreateApplicationJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectActivationCreateApplicationJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationCreateApplicationJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationCreateApplicationProblemJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ ProjectActivationCreateApplicationProblemJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationCreateApplicationProblemJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationCreateApplicationProblemJSONConflict_EncodeDecode(t *testing.T) {
	var typ ProjectActivationCreateApplicationProblemJSONConflict
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationCreateApplicationProblemJSONConflict
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationCreateApplicationProblemJSONForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectActivationCreateApplicationProblemJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationCreateApplicationProblemJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationCreateApplicationProblemJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectActivationCreateApplicationProblemJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationCreateApplicationProblemJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationReadApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectActivationReadApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationReadApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationReadApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectActivationReadApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationReadApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationReadApplicationJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectActivationReadApplicationJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationReadApplicationJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationReadApplicationProblemJSONForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectActivationReadApplicationProblemJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationReadApplicationProblemJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationReadApplicationProblemJSONNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectActivationReadApplicationProblemJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationReadApplicationProblemJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationReadApplicationProblemJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectActivationReadApplicationProblemJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationReadApplicationProblemJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationUpdateApplicationJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ ProjectActivationUpdateApplicationJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationUpdateApplicationJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationUpdateApplicationJSONForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectActivationUpdateApplicationJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationUpdateApplicationJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationUpdateApplicationJSONNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectActivationUpdateApplicationJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationUpdateApplicationJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationUpdateApplicationJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectActivationUpdateApplicationJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationUpdateApplicationJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationUpdateApplicationProblemJSONBadRequest_EncodeDecode(t *testing.T) {
	var typ ProjectActivationUpdateApplicationProblemJSONBadRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationUpdateApplicationProblemJSONBadRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationUpdateApplicationProblemJSONForbidden_EncodeDecode(t *testing.T) {
	var typ ProjectActivationUpdateApplicationProblemJSONForbidden
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationUpdateApplicationProblemJSONForbidden
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationUpdateApplicationProblemJSONNotFound_EncodeDecode(t *testing.T) {
	var typ ProjectActivationUpdateApplicationProblemJSONNotFound
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationUpdateApplicationProblemJSONNotFound
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestProjectActivationUpdateApplicationProblemJSONUnauthorized_EncodeDecode(t *testing.T) {
	var typ ProjectActivationUpdateApplicationProblemJSONUnauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ProjectActivationUpdateApplicationProblemJSONUnauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSakuraSimpleNotification_EncodeDecode(t *testing.T) {
	var typ SakuraSimpleNotification
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SakuraSimpleNotification
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestSakuraWorkflows_EncodeDecode(t *testing.T) {
	var typ SakuraWorkflows
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 SakuraWorkflows
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServerNoPublicIP_EncodeDecode(t *testing.T) {
	var typ ServerNoPublicIP
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServerNoPublicIP
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestServerNoPublicIPEvaluationRuleId_EncodeDecode(t *testing.T) {
	var typ ServerNoPublicIPEvaluationRuleId
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ServerNoPublicIPEvaluationRuleId
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTooManyRequests_EncodeDecode(t *testing.T) {
	var typ TooManyRequests
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TooManyRequests
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTooManyRequestsDetail_EncodeDecode(t *testing.T) {
	var typ TooManyRequestsDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TooManyRequestsDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTooManyRequestsStatus_EncodeDecode(t *testing.T) {
	var typ TooManyRequestsStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 TooManyRequestsStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnauthorized_EncodeDecode(t *testing.T) {
	var typ Unauthorized
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Unauthorized
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnauthorizedDetail_EncodeDecode(t *testing.T) {
	var typ UnauthorizedDetail
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnauthorizedDetail
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnauthorizedStatus_EncodeDecode(t *testing.T) {
	var typ UnauthorizedStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnauthorizedStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUnexpectedError_EncodeDecode(t *testing.T) {
	var typ UnexpectedError
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UnexpectedError
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
