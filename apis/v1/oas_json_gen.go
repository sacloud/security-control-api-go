// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"math/bits"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"
	"github.com/ogen-go/ogen/json"
	"github.com/ogen-go/ogen/validate"
)

// Encode implements json.Marshaler.
func (s *ActionDefinition) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionDefinition) encodeFields(e *jx.Encoder) {
	s.OneOf.encodeFields(e)
}

var jsonFieldsNameOfActionDefinition = [0]string{}

// Decode decodes ActionDefinition from json.
func (s *ActionDefinition) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionDefinition to nil")
	}
	if err := d.Capture(func(d *jx.Decoder) error {
		return s.OneOf.Decode(d)
	}); err != nil {
		return errors.Wrap(err, "decode field OneOf")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode ActionDefinition")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionDefinition) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionDefinition) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionDefinitionSimpleNotification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionDefinitionSimpleNotification) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("actionType")
		s.ActionType.Encode(e)
	}
	{
		e.FieldStart("actionParameter")
		s.ActionParameter.Encode(e)
	}
}

var jsonFieldsNameOfActionDefinitionSimpleNotification = [2]string{
	0: "actionType",
	1: "actionParameter",
}

// Decode decodes ActionDefinitionSimpleNotification from json.
func (s *ActionDefinitionSimpleNotification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionDefinitionSimpleNotification to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actionType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actionType\"")
			}
		case "actionParameter":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ActionParameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actionParameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionDefinitionSimpleNotification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionDefinitionSimpleNotification) {
					name = jsonFieldsNameOfActionDefinitionSimpleNotification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionDefinitionSimpleNotification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionDefinitionSimpleNotification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionDefinitionSimpleNotificationActionType as json.
func (s ActionDefinitionSimpleNotificationActionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionDefinitionSimpleNotificationActionType from json.
func (s *ActionDefinitionSimpleNotificationActionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionDefinitionSimpleNotificationActionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionDefinitionSimpleNotificationActionType(v) {
	case ActionDefinitionSimpleNotificationActionTypeSimpleNotification:
		*s = ActionDefinitionSimpleNotificationActionTypeSimpleNotification
	default:
		*s = ActionDefinitionSimpleNotificationActionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActionDefinitionSimpleNotificationActionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionDefinitionSimpleNotificationActionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionDefinitionSum as json.
func (s ActionDefinitionSum) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s ActionDefinitionSum) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ActionDefinitionSimpleNotificationActionDefinitionSum:
		e.FieldStart("actionType")
		e.Str("simpleNotification")
		{
			s := s.ActionDefinitionSimpleNotification
			{
				e.FieldStart("actionParameter")
				s.ActionParameter.Encode(e)
			}
		}
	case ActionDefinitionWorkflowsActionDefinitionSum:
		e.FieldStart("actionType")
		e.Str("workflows")
		{
			s := s.ActionDefinitionWorkflows
			{
				e.FieldStart("actionParameter")
				s.ActionParameter.Encode(e)
			}
		}
	}
}

// Decode decodes ActionDefinitionSum from json.
func (s *ActionDefinitionSum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionDefinitionSum to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "actionType":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "simpleNotification":
					s.Type = ActionDefinitionSimpleNotificationActionDefinitionSum
					found = true
				case "workflows":
					s.Type = ActionDefinitionWorkflowsActionDefinitionSum
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ActionDefinitionSimpleNotificationActionDefinitionSum:
		if err := s.ActionDefinitionSimpleNotification.Decode(d); err != nil {
			return err
		}
	case ActionDefinitionWorkflowsActionDefinitionSum:
		if err := s.ActionDefinitionWorkflows.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActionDefinitionSum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionDefinitionSum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActionDefinitionWorkflows) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActionDefinitionWorkflows) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("actionType")
		s.ActionType.Encode(e)
	}
	{
		e.FieldStart("actionParameter")
		s.ActionParameter.Encode(e)
	}
}

var jsonFieldsNameOfActionDefinitionWorkflows = [2]string{
	0: "actionType",
	1: "actionParameter",
}

// Decode decodes ActionDefinitionWorkflows from json.
func (s *ActionDefinitionWorkflows) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionDefinitionWorkflows to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "actionType":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.ActionType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actionType\"")
			}
		case "actionParameter":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.ActionParameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"actionParameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActionDefinitionWorkflows")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActionDefinitionWorkflows) {
					name = jsonFieldsNameOfActionDefinitionWorkflows[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActionDefinitionWorkflows) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionDefinitionWorkflows) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ActionDefinitionWorkflowsActionType as json.
func (s ActionDefinitionWorkflowsActionType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ActionDefinitionWorkflowsActionType from json.
func (s *ActionDefinitionWorkflowsActionType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActionDefinitionWorkflowsActionType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ActionDefinitionWorkflowsActionType(v) {
	case ActionDefinitionWorkflowsActionTypeWorkflows:
		*s = ActionDefinitionWorkflowsActionTypeWorkflows
	default:
		*s = ActionDefinitionWorkflowsActionType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ActionDefinitionWorkflowsActionType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActionDefinitionWorkflowsActionType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivationCreateInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivationCreateInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("servicePrincipalId")
		e.Str(s.ServicePrincipalId)
	}
}

var jsonFieldsNameOfActivationCreateInput = [1]string{
	0: "servicePrincipalId",
}

// Decode decodes ActivationCreateInput from json.
func (s *ActivationCreateInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivationCreateInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "servicePrincipalId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ServicePrincipalId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servicePrincipalId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivationCreateInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivationCreateInput) {
					name = jsonFieldsNameOfActivationCreateInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivationCreateInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivationCreateInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivationOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivationOutput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("servicePrincipalId")
		e.Str(s.ServicePrincipalId)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
	{
		e.FieldStart("automatedActionLimit")
		e.Int(s.AutomatedActionLimit)
	}
}

var jsonFieldsNameOfActivationOutput = [3]string{
	0: "servicePrincipalId",
	1: "isActive",
	2: "automatedActionLimit",
}

// Decode decodes ActivationOutput from json.
func (s *ActivationOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivationOutput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "servicePrincipalId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ServicePrincipalId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servicePrincipalId\"")
			}
		case "isActive":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		case "automatedActionLimit":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				v, err := d.Int()
				s.AutomatedActionLimit = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"automatedActionLimit\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivationOutput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000111,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivationOutput) {
					name = jsonFieldsNameOfActivationOutput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivationOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivationOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ActivationUpdateInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ActivationUpdateInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("servicePrincipalId")
		e.Str(s.ServicePrincipalId)
	}
	{
		e.FieldStart("isActive")
		e.Bool(s.IsActive)
	}
}

var jsonFieldsNameOfActivationUpdateInput = [2]string{
	0: "servicePrincipalId",
	1: "isActive",
}

// Decode decodes ActivationUpdateInput from json.
func (s *ActivationUpdateInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ActivationUpdateInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "servicePrincipalId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ServicePrincipalId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servicePrincipalId\"")
			}
		case "isActive":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsActive = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isActive\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ActivationUpdateInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfActivationUpdateInput) {
					name = jsonFieldsNameOfActivationUpdateInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ActivationUpdateInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ActivationUpdateInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddonDatalakeNoPublicAccess) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddonDatalakeNoPublicAccess) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddonDatalakeNoPublicAccess = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes AddonDatalakeNoPublicAccess from json.
func (s *AddonDatalakeNoPublicAccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddonDatalakeNoPublicAccess to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddonDatalakeNoPublicAccess")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddonDatalakeNoPublicAccess) {
					name = jsonFieldsNameOfAddonDatalakeNoPublicAccess[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddonDatalakeNoPublicAccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddonDatalakeNoPublicAccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddonDatalakeNoPublicAccessEvaluationRuleId as json.
func (s AddonDatalakeNoPublicAccessEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddonDatalakeNoPublicAccessEvaluationRuleId from json.
func (s *AddonDatalakeNoPublicAccessEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddonDatalakeNoPublicAccessEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddonDatalakeNoPublicAccessEvaluationRuleId(v) {
	case AddonDatalakeNoPublicAccessEvaluationRuleIdAddonDatalakeNoPublicAccess:
		*s = AddonDatalakeNoPublicAccessEvaluationRuleIdAddonDatalakeNoPublicAccess
	default:
		*s = AddonDatalakeNoPublicAccessEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddonDatalakeNoPublicAccessEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddonDatalakeNoPublicAccessEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddonDwhNoPublicAccess) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddonDwhNoPublicAccess) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddonDwhNoPublicAccess = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes AddonDwhNoPublicAccess from json.
func (s *AddonDwhNoPublicAccess) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddonDwhNoPublicAccess to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddonDwhNoPublicAccess")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddonDwhNoPublicAccess) {
					name = jsonFieldsNameOfAddonDwhNoPublicAccess[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddonDwhNoPublicAccess) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddonDwhNoPublicAccess) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddonDwhNoPublicAccessEvaluationRuleId as json.
func (s AddonDwhNoPublicAccessEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddonDwhNoPublicAccessEvaluationRuleId from json.
func (s *AddonDwhNoPublicAccessEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddonDwhNoPublicAccessEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddonDwhNoPublicAccessEvaluationRuleId(v) {
	case AddonDwhNoPublicAccessEvaluationRuleIdAddonDwhNoPublicAccess:
		*s = AddonDwhNoPublicAccessEvaluationRuleIdAddonDwhNoPublicAccess
	default:
		*s = AddonDwhNoPublicAccessEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddonDwhNoPublicAccessEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddonDwhNoPublicAccessEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddonThreatDetectionEnabled) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddonThreatDetectionEnabled) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfAddonThreatDetectionEnabled = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes AddonThreatDetectionEnabled from json.
func (s *AddonThreatDetectionEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddonThreatDetectionEnabled to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddonThreatDetectionEnabled")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddonThreatDetectionEnabled) {
					name = jsonFieldsNameOfAddonThreatDetectionEnabled[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddonThreatDetectionEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddonThreatDetectionEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddonThreatDetectionEnabledEvaluationRuleId as json.
func (s AddonThreatDetectionEnabledEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddonThreatDetectionEnabledEvaluationRuleId from json.
func (s *AddonThreatDetectionEnabledEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddonThreatDetectionEnabledEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddonThreatDetectionEnabledEvaluationRuleId(v) {
	case AddonThreatDetectionEnabledEvaluationRuleIdAddonThreatDetectionEnabled:
		*s = AddonThreatDetectionEnabledEvaluationRuleIdAddonThreatDetectionEnabled
	default:
		*s = AddonThreatDetectionEnabledEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddonThreatDetectionEnabledEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddonThreatDetectionEnabledEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddonThreatDetections) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddonThreatDetections) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
}

var jsonFieldsNameOfAddonThreatDetections = [1]string{
	0: "evaluationRuleId",
}

// Decode decodes AddonThreatDetections from json.
func (s *AddonThreatDetections) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddonThreatDetections to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddonThreatDetections")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddonThreatDetections) {
					name = jsonFieldsNameOfAddonThreatDetections[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddonThreatDetections) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddonThreatDetections) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddonThreatDetectionsEvaluationRuleId as json.
func (s AddonThreatDetectionsEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddonThreatDetectionsEvaluationRuleId from json.
func (s *AddonThreatDetectionsEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddonThreatDetectionsEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddonThreatDetectionsEvaluationRuleId(v) {
	case AddonThreatDetectionsEvaluationRuleIdAddonThreatDetections:
		*s = AddonThreatDetectionsEvaluationRuleIdAddonThreatDetections
	default:
		*s = AddonThreatDetectionsEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddonThreatDetectionsEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddonThreatDetectionsEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AddonVulnerabilityDetections) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AddonVulnerabilityDetections) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
}

var jsonFieldsNameOfAddonVulnerabilityDetections = [1]string{
	0: "evaluationRuleId",
}

// Decode decodes AddonVulnerabilityDetections from json.
func (s *AddonVulnerabilityDetections) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddonVulnerabilityDetections to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AddonVulnerabilityDetections")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAddonVulnerabilityDetections) {
					name = jsonFieldsNameOfAddonVulnerabilityDetections[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AddonVulnerabilityDetections) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddonVulnerabilityDetections) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AddonVulnerabilityDetectionsEvaluationRuleId as json.
func (s AddonVulnerabilityDetectionsEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes AddonVulnerabilityDetectionsEvaluationRuleId from json.
func (s *AddonVulnerabilityDetectionsEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AddonVulnerabilityDetectionsEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch AddonVulnerabilityDetectionsEvaluationRuleId(v) {
	case AddonVulnerabilityDetectionsEvaluationRuleIdAddonVulnerabilityDetections:
		*s = AddonVulnerabilityDetectionsEvaluationRuleIdAddonVulnerabilityDetections
	default:
		*s = AddonVulnerabilityDetectionsEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AddonVulnerabilityDetectionsEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AddonVulnerabilityDetectionsEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionID as json.
func (s AutomatedActionID) Encode(e *jx.Encoder) {
	unwrapped := string(s)

	e.Str(unwrapped)
}

// Decode decodes AutomatedActionID from json.
func (s *AutomatedActionID) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionID to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionID(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s AutomatedActionID) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionID) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutomatedActionInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutomatedActionInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
	{
		e.FieldStart("executionCondition")
		e.Str(s.ExecutionCondition)
	}
	{
		e.FieldStart("isEnabled")
		e.Bool(s.IsEnabled)
	}
}

var jsonFieldsNameOfAutomatedActionInput = [5]string{
	0: "name",
	1: "description",
	2: "action",
	3: "executionCondition",
	4: "isEnabled",
}

// Decode decodes AutomatedActionInput from json.
func (s *AutomatedActionInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "action":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "executionCondition":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Str()
				s.ExecutionCondition = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executionCondition\"")
			}
		case "isEnabled":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Bool()
				s.IsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEnabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutomatedActionInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00011101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutomatedActionInput) {
					name = jsonFieldsNameOfAutomatedActionInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutomatedActionOutput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutomatedActionOutput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("automatedActionId")
		s.AutomatedActionId.Encode(e)
	}
	{
		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("action")
		s.Action.Encode(e)
	}
	{
		e.FieldStart("executionCondition")
		e.Str(s.ExecutionCondition)
	}
	{
		e.FieldStart("isEnabled")
		e.Bool(s.IsEnabled)
	}
	{
		e.FieldStart("createdAt")
		json.EncodeDateTime(e, s.CreatedAt)
	}
}

var jsonFieldsNameOfAutomatedActionOutput = [7]string{
	0: "automatedActionId",
	1: "name",
	2: "description",
	3: "action",
	4: "executionCondition",
	5: "isEnabled",
	6: "createdAt",
}

// Decode decodes AutomatedActionOutput from json.
func (s *AutomatedActionOutput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionOutput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "automatedActionId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.AutomatedActionId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"automatedActionId\"")
			}
		case "name":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "action":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Action.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"action\"")
			}
		case "executionCondition":
			requiredBitSet[0] |= 1 << 4
			if err := func() error {
				v, err := d.Str()
				s.ExecutionCondition = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"executionCondition\"")
			}
		case "isEnabled":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Bool()
				s.IsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEnabled\"")
			}
		case "createdAt":
			requiredBitSet[0] |= 1 << 6
			if err := func() error {
				v, err := json.DecodeDateTime(d)
				s.CreatedAt = v
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"createdAt\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutomatedActionOutput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b01111011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutomatedActionOutput) {
					name = jsonFieldsNameOfAutomatedActionOutput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionOutput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionOutput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsCreateApplicationJSONBadRequest as json.
func (s *AutomatedActionsCreateApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsCreateApplicationJSONBadRequest from json.
func (s *AutomatedActionsCreateApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsCreateApplicationJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsCreateApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsCreateApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsCreateApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsCreateApplicationJSONForbidden as json.
func (s *AutomatedActionsCreateApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsCreateApplicationJSONForbidden from json.
func (s *AutomatedActionsCreateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsCreateApplicationJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsCreateApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsCreateApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsCreateApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsCreateApplicationJSONUnauthorized as json.
func (s *AutomatedActionsCreateApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsCreateApplicationJSONUnauthorized from json.
func (s *AutomatedActionsCreateApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsCreateApplicationJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsCreateApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsCreateApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsCreateApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsCreateApplicationProblemJSONBadRequest as json.
func (s *AutomatedActionsCreateApplicationProblemJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsCreateApplicationProblemJSONBadRequest from json.
func (s *AutomatedActionsCreateApplicationProblemJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsCreateApplicationProblemJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsCreateApplicationProblemJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsCreateApplicationProblemJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsCreateApplicationProblemJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsCreateApplicationProblemJSONForbidden as json.
func (s *AutomatedActionsCreateApplicationProblemJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsCreateApplicationProblemJSONForbidden from json.
func (s *AutomatedActionsCreateApplicationProblemJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsCreateApplicationProblemJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsCreateApplicationProblemJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsCreateApplicationProblemJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsCreateApplicationProblemJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsCreateApplicationProblemJSONUnauthorized as json.
func (s *AutomatedActionsCreateApplicationProblemJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsCreateApplicationProblemJSONUnauthorized from json.
func (s *AutomatedActionsCreateApplicationProblemJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsCreateApplicationProblemJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsCreateApplicationProblemJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsCreateApplicationProblemJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsCreateApplicationProblemJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsDeleteApplicationJSONForbidden as json.
func (s *AutomatedActionsDeleteApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsDeleteApplicationJSONForbidden from json.
func (s *AutomatedActionsDeleteApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsDeleteApplicationJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsDeleteApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsDeleteApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsDeleteApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsDeleteApplicationJSONUnauthorized as json.
func (s *AutomatedActionsDeleteApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsDeleteApplicationJSONUnauthorized from json.
func (s *AutomatedActionsDeleteApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsDeleteApplicationJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsDeleteApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsDeleteApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsDeleteApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsDeleteApplicationProblemJSONForbidden as json.
func (s *AutomatedActionsDeleteApplicationProblemJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsDeleteApplicationProblemJSONForbidden from json.
func (s *AutomatedActionsDeleteApplicationProblemJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsDeleteApplicationProblemJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsDeleteApplicationProblemJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsDeleteApplicationProblemJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsDeleteApplicationProblemJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsDeleteApplicationProblemJSONUnauthorized as json.
func (s *AutomatedActionsDeleteApplicationProblemJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsDeleteApplicationProblemJSONUnauthorized from json.
func (s *AutomatedActionsDeleteApplicationProblemJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsDeleteApplicationProblemJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsDeleteApplicationProblemJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsDeleteApplicationProblemJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsDeleteApplicationProblemJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsListApplicationJSONBadRequest as json.
func (s *AutomatedActionsListApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsListApplicationJSONBadRequest from json.
func (s *AutomatedActionsListApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsListApplicationJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsListApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsListApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsListApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsListApplicationJSONForbidden as json.
func (s *AutomatedActionsListApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsListApplicationJSONForbidden from json.
func (s *AutomatedActionsListApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsListApplicationJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsListApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsListApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsListApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsListApplicationJSONUnauthorized as json.
func (s *AutomatedActionsListApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsListApplicationJSONUnauthorized from json.
func (s *AutomatedActionsListApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsListApplicationJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsListApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsListApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsListApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsListApplicationProblemJSONBadRequest as json.
func (s *AutomatedActionsListApplicationProblemJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsListApplicationProblemJSONBadRequest from json.
func (s *AutomatedActionsListApplicationProblemJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsListApplicationProblemJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsListApplicationProblemJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsListApplicationProblemJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsListApplicationProblemJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsListApplicationProblemJSONForbidden as json.
func (s *AutomatedActionsListApplicationProblemJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsListApplicationProblemJSONForbidden from json.
func (s *AutomatedActionsListApplicationProblemJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsListApplicationProblemJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsListApplicationProblemJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsListApplicationProblemJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsListApplicationProblemJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsListApplicationProblemJSONUnauthorized as json.
func (s *AutomatedActionsListApplicationProblemJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsListApplicationProblemJSONUnauthorized from json.
func (s *AutomatedActionsListApplicationProblemJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsListApplicationProblemJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsListApplicationProblemJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsListApplicationProblemJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsListApplicationProblemJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *AutomatedActionsListOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *AutomatedActionsListOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.NextPageToken.Set {
			e.FieldStart("nextPageToken")
			s.NextPageToken.Encode(e)
		}
	}
	{
		if s.PrevPageToken.Set {
			e.FieldStart("prevPageToken")
			s.PrevPageToken.Encode(e)
		}
	}
	{
		e.FieldStart("totalSize")
		e.Int(s.TotalSize)
	}
}

var jsonFieldsNameOfAutomatedActionsListOK = [4]string{
	0: "items",
	1: "nextPageToken",
	2: "prevPageToken",
	3: "totalSize",
}

// Decode decodes AutomatedActionsListOK from json.
func (s *AutomatedActionsListOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsListOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]AutomatedActionOutput, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem AutomatedActionOutput
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "nextPageToken":
			if err := func() error {
				s.NextPageToken.Reset()
				if err := s.NextPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextPageToken\"")
			}
		case "prevPageToken":
			if err := func() error {
				s.PrevPageToken.Reset()
				if err := s.PrevPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prevPageToken\"")
			}
		case "totalSize":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalSize = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSize\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode AutomatedActionsListOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfAutomatedActionsListOK) {
					name = jsonFieldsNameOfAutomatedActionsListOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsListOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsListOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsReadApplicationJSONForbidden as json.
func (s *AutomatedActionsReadApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsReadApplicationJSONForbidden from json.
func (s *AutomatedActionsReadApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsReadApplicationJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsReadApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsReadApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsReadApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsReadApplicationJSONNotFound as json.
func (s *AutomatedActionsReadApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsReadApplicationJSONNotFound from json.
func (s *AutomatedActionsReadApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsReadApplicationJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsReadApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsReadApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsReadApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsReadApplicationJSONUnauthorized as json.
func (s *AutomatedActionsReadApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsReadApplicationJSONUnauthorized from json.
func (s *AutomatedActionsReadApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsReadApplicationJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsReadApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsReadApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsReadApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsReadApplicationProblemJSONForbidden as json.
func (s *AutomatedActionsReadApplicationProblemJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsReadApplicationProblemJSONForbidden from json.
func (s *AutomatedActionsReadApplicationProblemJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsReadApplicationProblemJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsReadApplicationProblemJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsReadApplicationProblemJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsReadApplicationProblemJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsReadApplicationProblemJSONNotFound as json.
func (s *AutomatedActionsReadApplicationProblemJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsReadApplicationProblemJSONNotFound from json.
func (s *AutomatedActionsReadApplicationProblemJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsReadApplicationProblemJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsReadApplicationProblemJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsReadApplicationProblemJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsReadApplicationProblemJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsReadApplicationProblemJSONUnauthorized as json.
func (s *AutomatedActionsReadApplicationProblemJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsReadApplicationProblemJSONUnauthorized from json.
func (s *AutomatedActionsReadApplicationProblemJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsReadApplicationProblemJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsReadApplicationProblemJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsReadApplicationProblemJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsReadApplicationProblemJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsUpdateApplicationJSONBadRequest as json.
func (s *AutomatedActionsUpdateApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsUpdateApplicationJSONBadRequest from json.
func (s *AutomatedActionsUpdateApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsUpdateApplicationJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsUpdateApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsUpdateApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsUpdateApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsUpdateApplicationJSONForbidden as json.
func (s *AutomatedActionsUpdateApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsUpdateApplicationJSONForbidden from json.
func (s *AutomatedActionsUpdateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsUpdateApplicationJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsUpdateApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsUpdateApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsUpdateApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsUpdateApplicationJSONNotFound as json.
func (s *AutomatedActionsUpdateApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsUpdateApplicationJSONNotFound from json.
func (s *AutomatedActionsUpdateApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsUpdateApplicationJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsUpdateApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsUpdateApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsUpdateApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsUpdateApplicationJSONUnauthorized as json.
func (s *AutomatedActionsUpdateApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsUpdateApplicationJSONUnauthorized from json.
func (s *AutomatedActionsUpdateApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsUpdateApplicationJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsUpdateApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsUpdateApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsUpdateApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsUpdateApplicationProblemJSONBadRequest as json.
func (s *AutomatedActionsUpdateApplicationProblemJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsUpdateApplicationProblemJSONBadRequest from json.
func (s *AutomatedActionsUpdateApplicationProblemJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsUpdateApplicationProblemJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsUpdateApplicationProblemJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsUpdateApplicationProblemJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsUpdateApplicationProblemJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsUpdateApplicationProblemJSONForbidden as json.
func (s *AutomatedActionsUpdateApplicationProblemJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsUpdateApplicationProblemJSONForbidden from json.
func (s *AutomatedActionsUpdateApplicationProblemJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsUpdateApplicationProblemJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsUpdateApplicationProblemJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsUpdateApplicationProblemJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsUpdateApplicationProblemJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsUpdateApplicationProblemJSONNotFound as json.
func (s *AutomatedActionsUpdateApplicationProblemJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsUpdateApplicationProblemJSONNotFound from json.
func (s *AutomatedActionsUpdateApplicationProblemJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsUpdateApplicationProblemJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsUpdateApplicationProblemJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsUpdateApplicationProblemJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsUpdateApplicationProblemJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes AutomatedActionsUpdateApplicationProblemJSONUnauthorized as json.
func (s *AutomatedActionsUpdateApplicationProblemJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes AutomatedActionsUpdateApplicationProblemJSONUnauthorized from json.
func (s *AutomatedActionsUpdateApplicationProblemJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode AutomatedActionsUpdateApplicationProblemJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = AutomatedActionsUpdateApplicationProblemJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *AutomatedActionsUpdateApplicationProblemJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *AutomatedActionsUpdateApplicationProblemJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *BadRequest) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *BadRequest) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("instance")
			s.Instance.Encode(e)
		}
	}
}

var jsonFieldsNameOfBadRequest = [5]string{
	0: "type",
	1: "title",
	2: "status",
	3: "detail",
	4: "instance",
}

// Decode decodes BadRequest from json.
func (s *BadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequest to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode BadRequest")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *BadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BadRequestDetail as json.
func (s BadRequestDetail) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes BadRequestDetail from json.
func (s *BadRequestDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestDetail to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch BadRequestDetail(v) {
	case BadRequestDetailInvalid:
		*s = BadRequestDetailInvalid
	default:
		*s = BadRequestDetail(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BadRequestDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BadRequestStatus as json.
func (s BadRequestStatus) Encode(e *jx.Encoder) {
	e.Float64(float64(s))
}

// Decode decodes BadRequestStatus from json.
func (s *BadRequestStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode BadRequestStatus to nil")
	}
	v, err := d.Float64()
	if err != nil {
		return err
	}
	*s = BadRequestStatus(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s BadRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *BadRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Conflict) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Conflict) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("instance")
			s.Instance.Encode(e)
		}
	}
}

var jsonFieldsNameOfConflict = [5]string{
	0: "type",
	1: "title",
	2: "status",
	3: "detail",
	4: "instance",
}

// Decode decodes Conflict from json.
func (s *Conflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Conflict to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Conflict")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Conflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Conflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConflictDetail as json.
func (s ConflictDetail) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ConflictDetail from json.
func (s *ConflictDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConflictDetail to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ConflictDetail(v) {
	case ConflictDetailConflict:
		*s = ConflictDetailConflict
	default:
		*s = ConflictDetail(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConflictDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConflictDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConflictStatus as json.
func (s ConflictStatus) Encode(e *jx.Encoder) {
	e.Float64(float64(s))
}

// Decode decodes ConflictStatus from json.
func (s *ConflictStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ConflictStatus to nil")
	}
	v, err := d.Float64()
	if err != nil {
		return err
	}
	*s = ConflictStatus(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ConflictStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ConflictStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaEncryptionEnabled) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaEncryptionEnabled) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaEncryptionEnabled = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes DbaEncryptionEnabled from json.
func (s *DbaEncryptionEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaEncryptionEnabled to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaEncryptionEnabled")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaEncryptionEnabled) {
					name = jsonFieldsNameOfDbaEncryptionEnabled[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaEncryptionEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaEncryptionEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaEncryptionEnabledEvaluationRuleId as json.
func (s DbaEncryptionEnabledEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DbaEncryptionEnabledEvaluationRuleId from json.
func (s *DbaEncryptionEnabledEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaEncryptionEnabledEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DbaEncryptionEnabledEvaluationRuleId(v) {
	case DbaEncryptionEnabledEvaluationRuleIdDbaEncryptionEnabled:
		*s = DbaEncryptionEnabledEvaluationRuleIdDbaEncryptionEnabled
	default:
		*s = DbaEncryptionEnabledEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaEncryptionEnabledEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaEncryptionEnabledEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DbaNoPublicIP) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DbaNoPublicIP) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfDbaNoPublicIP = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes DbaNoPublicIP from json.
func (s *DbaNoPublicIP) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaNoPublicIP to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DbaNoPublicIP")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDbaNoPublicIP) {
					name = jsonFieldsNameOfDbaNoPublicIP[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DbaNoPublicIP) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaNoPublicIP) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DbaNoPublicIPEvaluationRuleId as json.
func (s DbaNoPublicIPEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DbaNoPublicIPEvaluationRuleId from json.
func (s *DbaNoPublicIPEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DbaNoPublicIPEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DbaNoPublicIPEvaluationRuleId(v) {
	case DbaNoPublicIPEvaluationRuleIdDbaNoPublicIP:
		*s = DbaNoPublicIPEvaluationRuleIdDbaNoPublicIP
	default:
		*s = DbaNoPublicIPEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DbaNoPublicIPEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DbaNoPublicIPEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *DiskEncryptionEnabled) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *DiskEncryptionEnabled) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfDiskEncryptionEnabled = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes DiskEncryptionEnabled from json.
func (s *DiskEncryptionEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DiskEncryptionEnabled to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DiskEncryptionEnabled")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDiskEncryptionEnabled) {
					name = jsonFieldsNameOfDiskEncryptionEnabled[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *DiskEncryptionEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DiskEncryptionEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DiskEncryptionEnabledEvaluationRuleId as json.
func (s DiskEncryptionEnabledEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DiskEncryptionEnabledEvaluationRuleId from json.
func (s *DiskEncryptionEnabledEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DiskEncryptionEnabledEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DiskEncryptionEnabledEvaluationRuleId(v) {
	case DiskEncryptionEnabledEvaluationRuleIdDiskEncryptionEnabled:
		*s = DiskEncryptionEnabledEvaluationRuleIdDiskEncryptionEnabled
	default:
		*s = DiskEncryptionEnabledEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DiskEncryptionEnabledEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DiskEncryptionEnabledEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ELBLoggingEnabled) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ELBLoggingEnabled) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfELBLoggingEnabled = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes ELBLoggingEnabled from json.
func (s *ELBLoggingEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ELBLoggingEnabled to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ELBLoggingEnabled")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfELBLoggingEnabled) {
					name = jsonFieldsNameOfELBLoggingEnabled[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ELBLoggingEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ELBLoggingEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ELBLoggingEnabledEvaluationRuleId as json.
func (s ELBLoggingEnabledEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ELBLoggingEnabledEvaluationRuleId from json.
func (s *ELBLoggingEnabledEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ELBLoggingEnabledEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ELBLoggingEnabledEvaluationRuleId(v) {
	case ELBLoggingEnabledEvaluationRuleIdElbLoggingEnabled:
		*s = ELBLoggingEnabledEvaluationRuleIdElbLoggingEnabled
	default:
		*s = ELBLoggingEnabledEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ELBLoggingEnabledEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ELBLoggingEnabledEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EvaluationRule) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EvaluationRule) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rule")
		s.Rule.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		e.FieldStart("iamRolesRequired")
		e.ArrStart()
		for _, elem := range s.IamRolesRequired {
			e.Str(elem)
		}
		e.ArrEnd()
	}
	{
		e.FieldStart("isEnabled")
		e.Bool(s.IsEnabled)
	}
}

var jsonFieldsNameOfEvaluationRule = [4]string{
	0: "rule",
	1: "description",
	2: "iamRolesRequired",
	3: "isEnabled",
}

// Decode decodes EvaluationRule from json.
func (s *EvaluationRule) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRule to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rule":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "iamRolesRequired":
			requiredBitSet[0] |= 1 << 2
			if err := func() error {
				s.IamRolesRequired = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.IamRolesRequired = append(s.IamRolesRequired, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"iamRolesRequired\"")
			}
		case "isEnabled":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Bool()
				s.IsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEnabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EvaluationRule")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001101,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEvaluationRule) {
					name = jsonFieldsNameOfEvaluationRule[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRule) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRule) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EvaluationRuleInput) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EvaluationRuleInput) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("rule")
		s.Rule.Encode(e)
	}
	{
		e.FieldStart("isEnabled")
		e.Bool(s.IsEnabled)
	}
}

var jsonFieldsNameOfEvaluationRuleInput = [2]string{
	0: "rule",
	1: "isEnabled",
}

// Decode decodes EvaluationRuleInput from json.
func (s *EvaluationRuleInput) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRuleInput to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "rule":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.Rule.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"rule\"")
			}
		case "isEnabled":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Bool()
				s.IsEnabled = bool(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"isEnabled\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EvaluationRuleInput")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEvaluationRuleInput) {
					name = jsonFieldsNameOfEvaluationRuleInput[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRuleInput) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRuleInput) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EvaluationRuleParametersEvaluationTarget) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EvaluationRuleParametersEvaluationTarget) encodeFields(e *jx.Encoder) {
	{
		if s.ServicePrincipalId.Set {
			e.FieldStart("servicePrincipalId")
			s.ServicePrincipalId.Encode(e)
		}
	}
}

var jsonFieldsNameOfEvaluationRuleParametersEvaluationTarget = [1]string{
	0: "servicePrincipalId",
}

// Decode decodes EvaluationRuleParametersEvaluationTarget from json.
func (s *EvaluationRuleParametersEvaluationTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRuleParametersEvaluationTarget to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "servicePrincipalId":
			if err := func() error {
				s.ServicePrincipalId.Reset()
				if err := s.ServicePrincipalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servicePrincipalId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EvaluationRuleParametersEvaluationTarget")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRuleParametersEvaluationTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRuleParametersEvaluationTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EvaluationRuleParametersObjectStorageEvaluationTarget) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EvaluationRuleParametersObjectStorageEvaluationTarget) encodeFields(e *jx.Encoder) {
	{
		if s.ServicePrincipalId.Set {
			e.FieldStart("servicePrincipalId")
			s.ServicePrincipalId.Encode(e)
		}
	}
	{
		if s.Sites != nil {
			e.FieldStart("sites")
			e.ArrStart()
			for _, elem := range s.Sites {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEvaluationRuleParametersObjectStorageEvaluationTarget = [2]string{
	0: "servicePrincipalId",
	1: "sites",
}

// Decode decodes EvaluationRuleParametersObjectStorageEvaluationTarget from json.
func (s *EvaluationRuleParametersObjectStorageEvaluationTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRuleParametersObjectStorageEvaluationTarget to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "servicePrincipalId":
			if err := func() error {
				s.ServicePrincipalId.Reset()
				if err := s.ServicePrincipalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servicePrincipalId\"")
			}
		case "sites":
			if err := func() error {
				s.Sites = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Sites = append(s.Sites, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"sites\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EvaluationRuleParametersObjectStorageEvaluationTarget")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRuleParametersObjectStorageEvaluationTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRuleParametersObjectStorageEvaluationTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EvaluationRuleParametersZonedEvaluationTarget) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EvaluationRuleParametersZonedEvaluationTarget) encodeFields(e *jx.Encoder) {
	{
		if s.ServicePrincipalId.Set {
			e.FieldStart("servicePrincipalId")
			s.ServicePrincipalId.Encode(e)
		}
	}
	{
		if s.Zones != nil {
			e.FieldStart("zones")
			e.ArrStart()
			for _, elem := range s.Zones {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
}

var jsonFieldsNameOfEvaluationRuleParametersZonedEvaluationTarget = [2]string{
	0: "servicePrincipalId",
	1: "zones",
}

// Decode decodes EvaluationRuleParametersZonedEvaluationTarget from json.
func (s *EvaluationRuleParametersZonedEvaluationTarget) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRuleParametersZonedEvaluationTarget to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "servicePrincipalId":
			if err := func() error {
				s.ServicePrincipalId.Reset()
				if err := s.ServicePrincipalId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servicePrincipalId\"")
			}
		case "zones":
			if err := func() error {
				s.Zones = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Zones = append(s.Zones, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"zones\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EvaluationRuleParametersZonedEvaluationTarget")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRuleParametersZonedEvaluationTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRuleParametersZonedEvaluationTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EvaluationRuleUnion) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EvaluationRuleUnion) encodeFields(e *jx.Encoder) {
	s.OneOf.encodeFields(e)
}

var jsonFieldsNameOfEvaluationRuleUnion = [0]string{}

// Decode decodes EvaluationRuleUnion from json.
func (s *EvaluationRuleUnion) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRuleUnion to nil")
	}
	if err := d.Capture(func(d *jx.Decoder) error {
		return s.OneOf.Decode(d)
	}); err != nil {
		return errors.Wrap(err, "decode field OneOf")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			return d.Skip()
		}
	}); err != nil {
		return errors.Wrap(err, "decode EvaluationRuleUnion")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRuleUnion) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRuleUnion) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRuleUnionSum as json.
func (s EvaluationRuleUnionSum) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

func (s EvaluationRuleUnionSum) encodeFields(e *jx.Encoder) {
	switch s.Type {
	case ServerNoPublicIPEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("server-no-public-ip")
		{
			s := s.ServerNoPublicIP
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case DiskEncryptionEnabledEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("disk-encryption-enabled")
		{
			s := s.DiskEncryptionEnabled
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case DbaEncryptionEnabledEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("dba-encryption-enabled")
		{
			s := s.DbaEncryptionEnabled
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case DbaNoPublicIPEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("dba-no-public-ip")
		{
			s := s.DbaNoPublicIP
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case ObjectStorageBucketACLChangedEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("objectstorage-bucket-acl-changed")
		{
			s := s.ObjectStorageBucketACLChanged
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case ObjectStorageBucketEncryptionEnabledEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("objectstorage-bucket-encryption-enabled")
		{
			s := s.ObjectStorageBucketEncryptionEnabled
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case AddonDatalakeNoPublicAccessEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("addon-datalake-no-public-access")
		{
			s := s.AddonDatalakeNoPublicAccess
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case AddonDwhNoPublicAccessEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("addon-dwh-no-public-access")
		{
			s := s.AddonDwhNoPublicAccess
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case AddonThreatDetectionEnabledEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("addon-threat-detection-enabled")
		{
			s := s.AddonThreatDetectionEnabled
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case ELBLoggingEnabledEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("elb-logging-enabled")
		{
			s := s.ELBLoggingEnabled
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case IAMMemberOperationDetectedEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("iam-member-operation-detected")
		{
			s := s.IAMMemberOperationDetected
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case NoSQLEncryptionEnabledEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("nosql-encryption-enabled")
		{
			s := s.NoSQLEncryptionEnabled
			{
				if s.Parameter.Set {
					e.FieldStart("parameter")
					s.Parameter.Encode(e)
				}
			}
		}
	case AddonThreatDetectionsEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("addon-threat-detections")
	case AddonVulnerabilityDetectionsEvaluationRuleUnionSum:
		e.FieldStart("evaluationRuleId")
		e.Str("addon-vulnerability-detections")
	}
}

// Decode decodes EvaluationRuleUnionSum from json.
func (s *EvaluationRuleUnionSum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRuleUnionSum to nil")
	}
	// Sum type discriminator.
	if typ := d.Next(); typ != jx.Object {
		return errors.Errorf("unexpected json type %q", typ)
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "evaluationRuleId":
				typ, err := d.Str()
				if err != nil {
					return err
				}
				switch typ {
				case "server-no-public-ip":
					s.Type = ServerNoPublicIPEvaluationRuleUnionSum
					found = true
				case "disk-encryption-enabled":
					s.Type = DiskEncryptionEnabledEvaluationRuleUnionSum
					found = true
				case "dba-encryption-enabled":
					s.Type = DbaEncryptionEnabledEvaluationRuleUnionSum
					found = true
				case "dba-no-public-ip":
					s.Type = DbaNoPublicIPEvaluationRuleUnionSum
					found = true
				case "objectstorage-bucket-acl-changed":
					s.Type = ObjectStorageBucketACLChangedEvaluationRuleUnionSum
					found = true
				case "objectstorage-bucket-encryption-enabled":
					s.Type = ObjectStorageBucketEncryptionEnabledEvaluationRuleUnionSum
					found = true
				case "addon-datalake-no-public-access":
					s.Type = AddonDatalakeNoPublicAccessEvaluationRuleUnionSum
					found = true
				case "addon-dwh-no-public-access":
					s.Type = AddonDwhNoPublicAccessEvaluationRuleUnionSum
					found = true
				case "addon-threat-detection-enabled":
					s.Type = AddonThreatDetectionEnabledEvaluationRuleUnionSum
					found = true
				case "elb-logging-enabled":
					s.Type = ELBLoggingEnabledEvaluationRuleUnionSum
					found = true
				case "iam-member-operation-detected":
					s.Type = IAMMemberOperationDetectedEvaluationRuleUnionSum
					found = true
				case "nosql-encryption-enabled":
					s.Type = NoSQLEncryptionEnabledEvaluationRuleUnionSum
					found = true
				case "addon-threat-detections":
					s.Type = AddonThreatDetectionsEvaluationRuleUnionSum
					found = true
				case "addon-vulnerability-detections":
					s.Type = AddonVulnerabilityDetectionsEvaluationRuleUnionSum
					found = true
				default:
					return errors.Errorf("unknown type %s", typ)
				}
				return nil
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case ServerNoPublicIPEvaluationRuleUnionSum:
		if err := s.ServerNoPublicIP.Decode(d); err != nil {
			return err
		}
	case DiskEncryptionEnabledEvaluationRuleUnionSum:
		if err := s.DiskEncryptionEnabled.Decode(d); err != nil {
			return err
		}
	case DbaEncryptionEnabledEvaluationRuleUnionSum:
		if err := s.DbaEncryptionEnabled.Decode(d); err != nil {
			return err
		}
	case DbaNoPublicIPEvaluationRuleUnionSum:
		if err := s.DbaNoPublicIP.Decode(d); err != nil {
			return err
		}
	case ObjectStorageBucketACLChangedEvaluationRuleUnionSum:
		if err := s.ObjectStorageBucketACLChanged.Decode(d); err != nil {
			return err
		}
	case ObjectStorageBucketEncryptionEnabledEvaluationRuleUnionSum:
		if err := s.ObjectStorageBucketEncryptionEnabled.Decode(d); err != nil {
			return err
		}
	case AddonDatalakeNoPublicAccessEvaluationRuleUnionSum:
		if err := s.AddonDatalakeNoPublicAccess.Decode(d); err != nil {
			return err
		}
	case AddonDwhNoPublicAccessEvaluationRuleUnionSum:
		if err := s.AddonDwhNoPublicAccess.Decode(d); err != nil {
			return err
		}
	case AddonThreatDetectionEnabledEvaluationRuleUnionSum:
		if err := s.AddonThreatDetectionEnabled.Decode(d); err != nil {
			return err
		}
	case ELBLoggingEnabledEvaluationRuleUnionSum:
		if err := s.ELBLoggingEnabled.Decode(d); err != nil {
			return err
		}
	case IAMMemberOperationDetectedEvaluationRuleUnionSum:
		if err := s.IAMMemberOperationDetected.Decode(d); err != nil {
			return err
		}
	case NoSQLEncryptionEnabledEvaluationRuleUnionSum:
		if err := s.NoSQLEncryptionEnabled.Decode(d); err != nil {
			return err
		}
	case AddonThreatDetectionsEvaluationRuleUnionSum:
		if err := s.AddonThreatDetections.Decode(d); err != nil {
			return err
		}
	case AddonVulnerabilityDetectionsEvaluationRuleUnionSum:
		if err := s.AddonVulnerabilityDetections.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s EvaluationRuleUnionSum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRuleUnionSum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesListApplicationJSONBadRequest as json.
func (s *EvaluationRulesListApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesListApplicationJSONBadRequest from json.
func (s *EvaluationRulesListApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesListApplicationJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesListApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesListApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesListApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesListApplicationJSONForbidden as json.
func (s *EvaluationRulesListApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesListApplicationJSONForbidden from json.
func (s *EvaluationRulesListApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesListApplicationJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesListApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesListApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesListApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesListApplicationJSONNotFound as json.
func (s *EvaluationRulesListApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesListApplicationJSONNotFound from json.
func (s *EvaluationRulesListApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesListApplicationJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesListApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesListApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesListApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesListApplicationJSONUnauthorized as json.
func (s *EvaluationRulesListApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesListApplicationJSONUnauthorized from json.
func (s *EvaluationRulesListApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesListApplicationJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesListApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesListApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesListApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesListApplicationProblemJSONBadRequest as json.
func (s *EvaluationRulesListApplicationProblemJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesListApplicationProblemJSONBadRequest from json.
func (s *EvaluationRulesListApplicationProblemJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesListApplicationProblemJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesListApplicationProblemJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesListApplicationProblemJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesListApplicationProblemJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesListApplicationProblemJSONForbidden as json.
func (s *EvaluationRulesListApplicationProblemJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesListApplicationProblemJSONForbidden from json.
func (s *EvaluationRulesListApplicationProblemJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesListApplicationProblemJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesListApplicationProblemJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesListApplicationProblemJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesListApplicationProblemJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesListApplicationProblemJSONNotFound as json.
func (s *EvaluationRulesListApplicationProblemJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesListApplicationProblemJSONNotFound from json.
func (s *EvaluationRulesListApplicationProblemJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesListApplicationProblemJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesListApplicationProblemJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesListApplicationProblemJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesListApplicationProblemJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesListApplicationProblemJSONUnauthorized as json.
func (s *EvaluationRulesListApplicationProblemJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesListApplicationProblemJSONUnauthorized from json.
func (s *EvaluationRulesListApplicationProblemJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesListApplicationProblemJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesListApplicationProblemJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesListApplicationProblemJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesListApplicationProblemJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *EvaluationRulesListOK) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *EvaluationRulesListOK) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("items")
		e.ArrStart()
		for _, elem := range s.Items {
			elem.Encode(e)
		}
		e.ArrEnd()
	}
	{
		if s.NextPageToken.Set {
			e.FieldStart("nextPageToken")
			s.NextPageToken.Encode(e)
		}
	}
	{
		if s.PrevPageToken.Set {
			e.FieldStart("prevPageToken")
			s.PrevPageToken.Encode(e)
		}
	}
	{
		e.FieldStart("totalSize")
		e.Int(s.TotalSize)
	}
}

var jsonFieldsNameOfEvaluationRulesListOK = [4]string{
	0: "items",
	1: "nextPageToken",
	2: "prevPageToken",
	3: "totalSize",
}

// Decode decodes EvaluationRulesListOK from json.
func (s *EvaluationRulesListOK) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesListOK to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "items":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				s.Items = make([]EvaluationRule, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem EvaluationRule
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Items = append(s.Items, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "nextPageToken":
			if err := func() error {
				s.NextPageToken.Reset()
				if err := s.NextPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nextPageToken\"")
			}
		case "prevPageToken":
			if err := func() error {
				s.PrevPageToken.Reset()
				if err := s.PrevPageToken.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prevPageToken\"")
			}
		case "totalSize":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				v, err := d.Int()
				s.TotalSize = int(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"totalSize\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode EvaluationRulesListOK")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfEvaluationRulesListOK) {
					name = jsonFieldsNameOfEvaluationRulesListOK[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesListOK) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesListOK) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesReadApplicationJSONForbidden as json.
func (s *EvaluationRulesReadApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesReadApplicationJSONForbidden from json.
func (s *EvaluationRulesReadApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesReadApplicationJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesReadApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesReadApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesReadApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesReadApplicationJSONNotFound as json.
func (s *EvaluationRulesReadApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesReadApplicationJSONNotFound from json.
func (s *EvaluationRulesReadApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesReadApplicationJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesReadApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesReadApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesReadApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesReadApplicationJSONUnauthorized as json.
func (s *EvaluationRulesReadApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesReadApplicationJSONUnauthorized from json.
func (s *EvaluationRulesReadApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesReadApplicationJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesReadApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesReadApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesReadApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesReadApplicationProblemJSONForbidden as json.
func (s *EvaluationRulesReadApplicationProblemJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesReadApplicationProblemJSONForbidden from json.
func (s *EvaluationRulesReadApplicationProblemJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesReadApplicationProblemJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesReadApplicationProblemJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesReadApplicationProblemJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesReadApplicationProblemJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesReadApplicationProblemJSONNotFound as json.
func (s *EvaluationRulesReadApplicationProblemJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesReadApplicationProblemJSONNotFound from json.
func (s *EvaluationRulesReadApplicationProblemJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesReadApplicationProblemJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesReadApplicationProblemJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesReadApplicationProblemJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesReadApplicationProblemJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesReadApplicationProblemJSONUnauthorized as json.
func (s *EvaluationRulesReadApplicationProblemJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesReadApplicationProblemJSONUnauthorized from json.
func (s *EvaluationRulesReadApplicationProblemJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesReadApplicationProblemJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesReadApplicationProblemJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesReadApplicationProblemJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesReadApplicationProblemJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesUpdateApplicationJSONBadRequest as json.
func (s *EvaluationRulesUpdateApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesUpdateApplicationJSONBadRequest from json.
func (s *EvaluationRulesUpdateApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesUpdateApplicationJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesUpdateApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesUpdateApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesUpdateApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesUpdateApplicationJSONForbidden as json.
func (s *EvaluationRulesUpdateApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesUpdateApplicationJSONForbidden from json.
func (s *EvaluationRulesUpdateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesUpdateApplicationJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesUpdateApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesUpdateApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesUpdateApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesUpdateApplicationJSONNotFound as json.
func (s *EvaluationRulesUpdateApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesUpdateApplicationJSONNotFound from json.
func (s *EvaluationRulesUpdateApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesUpdateApplicationJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesUpdateApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesUpdateApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesUpdateApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesUpdateApplicationJSONUnauthorized as json.
func (s *EvaluationRulesUpdateApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesUpdateApplicationJSONUnauthorized from json.
func (s *EvaluationRulesUpdateApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesUpdateApplicationJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesUpdateApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesUpdateApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesUpdateApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesUpdateApplicationProblemJSONBadRequest as json.
func (s *EvaluationRulesUpdateApplicationProblemJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesUpdateApplicationProblemJSONBadRequest from json.
func (s *EvaluationRulesUpdateApplicationProblemJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesUpdateApplicationProblemJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesUpdateApplicationProblemJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesUpdateApplicationProblemJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesUpdateApplicationProblemJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesUpdateApplicationProblemJSONForbidden as json.
func (s *EvaluationRulesUpdateApplicationProblemJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesUpdateApplicationProblemJSONForbidden from json.
func (s *EvaluationRulesUpdateApplicationProblemJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesUpdateApplicationProblemJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesUpdateApplicationProblemJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesUpdateApplicationProblemJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesUpdateApplicationProblemJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesUpdateApplicationProblemJSONNotFound as json.
func (s *EvaluationRulesUpdateApplicationProblemJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesUpdateApplicationProblemJSONNotFound from json.
func (s *EvaluationRulesUpdateApplicationProblemJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesUpdateApplicationProblemJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesUpdateApplicationProblemJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesUpdateApplicationProblemJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesUpdateApplicationProblemJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRulesUpdateApplicationProblemJSONUnauthorized as json.
func (s *EvaluationRulesUpdateApplicationProblemJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes EvaluationRulesUpdateApplicationProblemJSONUnauthorized from json.
func (s *EvaluationRulesUpdateApplicationProblemJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode EvaluationRulesUpdateApplicationProblemJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = EvaluationRulesUpdateApplicationProblemJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *EvaluationRulesUpdateApplicationProblemJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *EvaluationRulesUpdateApplicationProblemJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Forbidden) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Forbidden) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("instance")
			s.Instance.Encode(e)
		}
	}
}

var jsonFieldsNameOfForbidden = [5]string{
	0: "type",
	1: "title",
	2: "status",
	3: "detail",
	4: "instance",
}

// Decode decodes Forbidden from json.
func (s *Forbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Forbidden to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Forbidden")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Forbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Forbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ForbiddenDetail as json.
func (s ForbiddenDetail) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ForbiddenDetail from json.
func (s *ForbiddenDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForbiddenDetail to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ForbiddenDetail(v) {
	case ForbiddenDetailForbidden:
		*s = ForbiddenDetailForbidden
	default:
		*s = ForbiddenDetail(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ForbiddenDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForbiddenDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ForbiddenStatus as json.
func (s ForbiddenStatus) Encode(e *jx.Encoder) {
	e.Float64(float64(s))
}

// Decode decodes ForbiddenStatus from json.
func (s *ForbiddenStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ForbiddenStatus to nil")
	}
	v, err := d.Float64()
	if err != nil {
		return err
	}
	*s = ForbiddenStatus(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ForbiddenStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ForbiddenStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *IAMMemberOperationDetected) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *IAMMemberOperationDetected) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfIAMMemberOperationDetected = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes IAMMemberOperationDetected from json.
func (s *IAMMemberOperationDetected) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IAMMemberOperationDetected to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode IAMMemberOperationDetected")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfIAMMemberOperationDetected) {
					name = jsonFieldsNameOfIAMMemberOperationDetected[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *IAMMemberOperationDetected) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IAMMemberOperationDetected) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes IAMMemberOperationDetectedEvaluationRuleId as json.
func (s IAMMemberOperationDetectedEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes IAMMemberOperationDetectedEvaluationRuleId from json.
func (s *IAMMemberOperationDetectedEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode IAMMemberOperationDetectedEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch IAMMemberOperationDetectedEvaluationRuleId(v) {
	case IAMMemberOperationDetectedEvaluationRuleIdIamMemberOperationDetected:
		*s = IAMMemberOperationDetectedEvaluationRuleIdIamMemberOperationDetected
	default:
		*s = IAMMemberOperationDetectedEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s IAMMemberOperationDetectedEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *IAMMemberOperationDetectedEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NoSQLEncryptionEnabled) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NoSQLEncryptionEnabled) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfNoSQLEncryptionEnabled = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes NoSQLEncryptionEnabled from json.
func (s *NoSQLEncryptionEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NoSQLEncryptionEnabled to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NoSQLEncryptionEnabled")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfNoSQLEncryptionEnabled) {
					name = jsonFieldsNameOfNoSQLEncryptionEnabled[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NoSQLEncryptionEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NoSQLEncryptionEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NoSQLEncryptionEnabledEvaluationRuleId as json.
func (s NoSQLEncryptionEnabledEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NoSQLEncryptionEnabledEvaluationRuleId from json.
func (s *NoSQLEncryptionEnabledEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NoSQLEncryptionEnabledEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NoSQLEncryptionEnabledEvaluationRuleId(v) {
	case NoSQLEncryptionEnabledEvaluationRuleIdNosqlEncryptionEnabled:
		*s = NoSQLEncryptionEnabledEvaluationRuleIdNosqlEncryptionEnabled
	default:
		*s = NoSQLEncryptionEnabledEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NoSQLEncryptionEnabledEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NoSQLEncryptionEnabledEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *NotFound) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *NotFound) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("instance")
			s.Instance.Encode(e)
		}
	}
}

var jsonFieldsNameOfNotFound = [5]string{
	0: "type",
	1: "title",
	2: "status",
	3: "detail",
	4: "instance",
}

// Decode decodes NotFound from json.
func (s *NotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFound to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode NotFound")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *NotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotFoundDetail as json.
func (s NotFoundDetail) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes NotFoundDetail from json.
func (s *NotFoundDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFoundDetail to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch NotFoundDetail(v) {
	case NotFoundDetailNotFound:
		*s = NotFoundDetailNotFound
	default:
		*s = NotFoundDetail(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotFoundDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFoundDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotFoundStatus as json.
func (s NotFoundStatus) Encode(e *jx.Encoder) {
	e.Float64(float64(s))
}

// Decode decodes NotFoundStatus from json.
func (s *NotFoundStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode NotFoundStatus to nil")
	}
	v, err := d.Float64()
	if err != nil {
		return err
	}
	*s = NotFoundStatus(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s NotFoundStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *NotFoundStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectStorageBucketACLChanged) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectStorageBucketACLChanged) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfObjectStorageBucketACLChanged = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes ObjectStorageBucketACLChanged from json.
func (s *ObjectStorageBucketACLChanged) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectStorageBucketACLChanged to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectStorageBucketACLChanged")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfObjectStorageBucketACLChanged) {
					name = jsonFieldsNameOfObjectStorageBucketACLChanged[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectStorageBucketACLChanged) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectStorageBucketACLChanged) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectStorageBucketACLChangedEvaluationRuleId as json.
func (s ObjectStorageBucketACLChangedEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ObjectStorageBucketACLChangedEvaluationRuleId from json.
func (s *ObjectStorageBucketACLChangedEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectStorageBucketACLChangedEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ObjectStorageBucketACLChangedEvaluationRuleId(v) {
	case ObjectStorageBucketACLChangedEvaluationRuleIdObjectstorageBucketACLChanged:
		*s = ObjectStorageBucketACLChangedEvaluationRuleIdObjectstorageBucketACLChanged
	default:
		*s = ObjectStorageBucketACLChangedEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ObjectStorageBucketACLChangedEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectStorageBucketACLChangedEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ObjectStorageBucketEncryptionEnabled) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ObjectStorageBucketEncryptionEnabled) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfObjectStorageBucketEncryptionEnabled = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes ObjectStorageBucketEncryptionEnabled from json.
func (s *ObjectStorageBucketEncryptionEnabled) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectStorageBucketEncryptionEnabled to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ObjectStorageBucketEncryptionEnabled")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfObjectStorageBucketEncryptionEnabled) {
					name = jsonFieldsNameOfObjectStorageBucketEncryptionEnabled[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ObjectStorageBucketEncryptionEnabled) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectStorageBucketEncryptionEnabled) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ObjectStorageBucketEncryptionEnabledEvaluationRuleId as json.
func (s ObjectStorageBucketEncryptionEnabledEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ObjectStorageBucketEncryptionEnabledEvaluationRuleId from json.
func (s *ObjectStorageBucketEncryptionEnabledEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ObjectStorageBucketEncryptionEnabledEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ObjectStorageBucketEncryptionEnabledEvaluationRuleId(v) {
	case ObjectStorageBucketEncryptionEnabledEvaluationRuleIdObjectstorageBucketEncryptionEnabled:
		*s = ObjectStorageBucketEncryptionEnabledEvaluationRuleIdObjectstorageBucketEncryptionEnabled
	default:
		*s = ObjectStorageBucketEncryptionEnabledEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ObjectStorageBucketEncryptionEnabledEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ObjectStorageBucketEncryptionEnabledEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BadRequestDetail as json.
func (o OptBadRequestDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes BadRequestDetail from json.
func (o *OptBadRequestDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBadRequestDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBadRequestDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBadRequestDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes BadRequestStatus as json.
func (o OptBadRequestStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes BadRequestStatus from json.
func (o *OptBadRequestStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBadRequestStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBadRequestStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBadRequestStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConflictDetail as json.
func (o OptConflictDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ConflictDetail from json.
func (o *OptConflictDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConflictDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConflictDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConflictDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ConflictStatus as json.
func (o OptConflictStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes ConflictStatus from json.
func (o *OptConflictStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptConflictStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptConflictStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptConflictStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRuleParametersEvaluationTarget as json.
func (o OptEvaluationRuleParametersEvaluationTarget) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EvaluationRuleParametersEvaluationTarget from json.
func (o *OptEvaluationRuleParametersEvaluationTarget) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEvaluationRuleParametersEvaluationTarget to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEvaluationRuleParametersEvaluationTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEvaluationRuleParametersEvaluationTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRuleParametersObjectStorageEvaluationTarget as json.
func (o OptEvaluationRuleParametersObjectStorageEvaluationTarget) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EvaluationRuleParametersObjectStorageEvaluationTarget from json.
func (o *OptEvaluationRuleParametersObjectStorageEvaluationTarget) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEvaluationRuleParametersObjectStorageEvaluationTarget to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEvaluationRuleParametersObjectStorageEvaluationTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEvaluationRuleParametersObjectStorageEvaluationTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes EvaluationRuleParametersZonedEvaluationTarget as json.
func (o OptEvaluationRuleParametersZonedEvaluationTarget) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes EvaluationRuleParametersZonedEvaluationTarget from json.
func (o *OptEvaluationRuleParametersZonedEvaluationTarget) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptEvaluationRuleParametersZonedEvaluationTarget to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptEvaluationRuleParametersZonedEvaluationTarget) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptEvaluationRuleParametersZonedEvaluationTarget) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ForbiddenDetail as json.
func (o OptForbiddenDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes ForbiddenDetail from json.
func (o *OptForbiddenDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptForbiddenDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptForbiddenDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptForbiddenDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ForbiddenStatus as json.
func (o OptForbiddenStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes ForbiddenStatus from json.
func (o *OptForbiddenStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptForbiddenStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptForbiddenStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptForbiddenStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes int as json.
func (o OptInt) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Int(int(o.Value))
}

// Decode decodes int from json.
func (o *OptInt) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptInt to nil")
	}
	o.Set = true
	v, err := d.Int()
	if err != nil {
		return err
	}
	o.Value = int(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptInt) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptInt) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotFoundDetail as json.
func (o OptNotFoundDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes NotFoundDetail from json.
func (o *OptNotFoundDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotFoundDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotFoundDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotFoundDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes NotFoundStatus as json.
func (o OptNotFoundStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes NotFoundStatus from json.
func (o *OptNotFoundStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptNotFoundStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptNotFoundStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptNotFoundStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TooManyRequestsDetail as json.
func (o OptTooManyRequestsDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes TooManyRequestsDetail from json.
func (o *OptTooManyRequestsDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTooManyRequestsDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTooManyRequestsDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTooManyRequestsDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TooManyRequestsStatus as json.
func (o OptTooManyRequestsStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes TooManyRequestsStatus from json.
func (o *OptTooManyRequestsStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptTooManyRequestsStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptTooManyRequestsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptTooManyRequestsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnauthorizedDetail as json.
func (o OptUnauthorizedDetail) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes UnauthorizedDetail from json.
func (o *OptUnauthorizedDetail) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUnauthorizedDetail to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUnauthorizedDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUnauthorizedDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnauthorizedStatus as json.
func (o OptUnauthorizedStatus) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Float64(float64(o.Value))
}

// Decode decodes UnauthorizedStatus from json.
func (o *OptUnauthorizedStatus) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptUnauthorizedStatus to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptUnauthorizedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptUnauthorizedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationCreateApplicationJSONBadRequest as json.
func (s *ProjectActivationCreateApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationCreateApplicationJSONBadRequest from json.
func (s *ProjectActivationCreateApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationCreateApplicationJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationCreateApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationCreateApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationCreateApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationCreateApplicationJSONConflict as json.
func (s *ProjectActivationCreateApplicationJSONConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Conflict)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationCreateApplicationJSONConflict from json.
func (s *ProjectActivationCreateApplicationJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationCreateApplicationJSONConflict to nil")
	}
	var unwrapped Conflict
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationCreateApplicationJSONConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationCreateApplicationJSONConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationCreateApplicationJSONConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationCreateApplicationJSONForbidden as json.
func (s *ProjectActivationCreateApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationCreateApplicationJSONForbidden from json.
func (s *ProjectActivationCreateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationCreateApplicationJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationCreateApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationCreateApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationCreateApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationCreateApplicationJSONUnauthorized as json.
func (s *ProjectActivationCreateApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationCreateApplicationJSONUnauthorized from json.
func (s *ProjectActivationCreateApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationCreateApplicationJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationCreateApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationCreateApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationCreateApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationCreateApplicationProblemJSONBadRequest as json.
func (s *ProjectActivationCreateApplicationProblemJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationCreateApplicationProblemJSONBadRequest from json.
func (s *ProjectActivationCreateApplicationProblemJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationCreateApplicationProblemJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationCreateApplicationProblemJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationCreateApplicationProblemJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationCreateApplicationProblemJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationCreateApplicationProblemJSONConflict as json.
func (s *ProjectActivationCreateApplicationProblemJSONConflict) Encode(e *jx.Encoder) {
	unwrapped := (*Conflict)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationCreateApplicationProblemJSONConflict from json.
func (s *ProjectActivationCreateApplicationProblemJSONConflict) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationCreateApplicationProblemJSONConflict to nil")
	}
	var unwrapped Conflict
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationCreateApplicationProblemJSONConflict(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationCreateApplicationProblemJSONConflict) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationCreateApplicationProblemJSONConflict) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationCreateApplicationProblemJSONForbidden as json.
func (s *ProjectActivationCreateApplicationProblemJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationCreateApplicationProblemJSONForbidden from json.
func (s *ProjectActivationCreateApplicationProblemJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationCreateApplicationProblemJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationCreateApplicationProblemJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationCreateApplicationProblemJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationCreateApplicationProblemJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationCreateApplicationProblemJSONUnauthorized as json.
func (s *ProjectActivationCreateApplicationProblemJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationCreateApplicationProblemJSONUnauthorized from json.
func (s *ProjectActivationCreateApplicationProblemJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationCreateApplicationProblemJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationCreateApplicationProblemJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationCreateApplicationProblemJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationCreateApplicationProblemJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationReadApplicationJSONForbidden as json.
func (s *ProjectActivationReadApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationReadApplicationJSONForbidden from json.
func (s *ProjectActivationReadApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationReadApplicationJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationReadApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationReadApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationReadApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationReadApplicationJSONNotFound as json.
func (s *ProjectActivationReadApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationReadApplicationJSONNotFound from json.
func (s *ProjectActivationReadApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationReadApplicationJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationReadApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationReadApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationReadApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationReadApplicationJSONUnauthorized as json.
func (s *ProjectActivationReadApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationReadApplicationJSONUnauthorized from json.
func (s *ProjectActivationReadApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationReadApplicationJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationReadApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationReadApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationReadApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationReadApplicationProblemJSONForbidden as json.
func (s *ProjectActivationReadApplicationProblemJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationReadApplicationProblemJSONForbidden from json.
func (s *ProjectActivationReadApplicationProblemJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationReadApplicationProblemJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationReadApplicationProblemJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationReadApplicationProblemJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationReadApplicationProblemJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationReadApplicationProblemJSONNotFound as json.
func (s *ProjectActivationReadApplicationProblemJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationReadApplicationProblemJSONNotFound from json.
func (s *ProjectActivationReadApplicationProblemJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationReadApplicationProblemJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationReadApplicationProblemJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationReadApplicationProblemJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationReadApplicationProblemJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationReadApplicationProblemJSONUnauthorized as json.
func (s *ProjectActivationReadApplicationProblemJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationReadApplicationProblemJSONUnauthorized from json.
func (s *ProjectActivationReadApplicationProblemJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationReadApplicationProblemJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationReadApplicationProblemJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationReadApplicationProblemJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationReadApplicationProblemJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationUpdateApplicationJSONBadRequest as json.
func (s *ProjectActivationUpdateApplicationJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationUpdateApplicationJSONBadRequest from json.
func (s *ProjectActivationUpdateApplicationJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationUpdateApplicationJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationUpdateApplicationJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationUpdateApplicationJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationUpdateApplicationJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationUpdateApplicationJSONForbidden as json.
func (s *ProjectActivationUpdateApplicationJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationUpdateApplicationJSONForbidden from json.
func (s *ProjectActivationUpdateApplicationJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationUpdateApplicationJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationUpdateApplicationJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationUpdateApplicationJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationUpdateApplicationJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationUpdateApplicationJSONNotFound as json.
func (s *ProjectActivationUpdateApplicationJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationUpdateApplicationJSONNotFound from json.
func (s *ProjectActivationUpdateApplicationJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationUpdateApplicationJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationUpdateApplicationJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationUpdateApplicationJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationUpdateApplicationJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationUpdateApplicationJSONUnauthorized as json.
func (s *ProjectActivationUpdateApplicationJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationUpdateApplicationJSONUnauthorized from json.
func (s *ProjectActivationUpdateApplicationJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationUpdateApplicationJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationUpdateApplicationJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationUpdateApplicationJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationUpdateApplicationJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationUpdateApplicationProblemJSONBadRequest as json.
func (s *ProjectActivationUpdateApplicationProblemJSONBadRequest) Encode(e *jx.Encoder) {
	unwrapped := (*BadRequest)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationUpdateApplicationProblemJSONBadRequest from json.
func (s *ProjectActivationUpdateApplicationProblemJSONBadRequest) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationUpdateApplicationProblemJSONBadRequest to nil")
	}
	var unwrapped BadRequest
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationUpdateApplicationProblemJSONBadRequest(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationUpdateApplicationProblemJSONBadRequest) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationUpdateApplicationProblemJSONBadRequest) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationUpdateApplicationProblemJSONForbidden as json.
func (s *ProjectActivationUpdateApplicationProblemJSONForbidden) Encode(e *jx.Encoder) {
	unwrapped := (*Forbidden)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationUpdateApplicationProblemJSONForbidden from json.
func (s *ProjectActivationUpdateApplicationProblemJSONForbidden) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationUpdateApplicationProblemJSONForbidden to nil")
	}
	var unwrapped Forbidden
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationUpdateApplicationProblemJSONForbidden(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationUpdateApplicationProblemJSONForbidden) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationUpdateApplicationProblemJSONForbidden) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationUpdateApplicationProblemJSONNotFound as json.
func (s *ProjectActivationUpdateApplicationProblemJSONNotFound) Encode(e *jx.Encoder) {
	unwrapped := (*NotFound)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationUpdateApplicationProblemJSONNotFound from json.
func (s *ProjectActivationUpdateApplicationProblemJSONNotFound) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationUpdateApplicationProblemJSONNotFound to nil")
	}
	var unwrapped NotFound
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationUpdateApplicationProblemJSONNotFound(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationUpdateApplicationProblemJSONNotFound) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationUpdateApplicationProblemJSONNotFound) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ProjectActivationUpdateApplicationProblemJSONUnauthorized as json.
func (s *ProjectActivationUpdateApplicationProblemJSONUnauthorized) Encode(e *jx.Encoder) {
	unwrapped := (*Unauthorized)(s)

	unwrapped.Encode(e)
}

// Decode decodes ProjectActivationUpdateApplicationProblemJSONUnauthorized from json.
func (s *ProjectActivationUpdateApplicationProblemJSONUnauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ProjectActivationUpdateApplicationProblemJSONUnauthorized to nil")
	}
	var unwrapped Unauthorized
	if err := func() error {
		if err := unwrapped.Decode(d); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = ProjectActivationUpdateApplicationProblemJSONUnauthorized(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ProjectActivationUpdateApplicationProblemJSONUnauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ProjectActivationUpdateApplicationProblemJSONUnauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SakuraSimpleNotification) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SakuraSimpleNotification) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("servicePrincipalId")
		e.Str(s.ServicePrincipalId)
	}
	{
		e.FieldStart("notificationGroupId")
		e.Str(s.NotificationGroupId)
	}
}

var jsonFieldsNameOfSakuraSimpleNotification = [2]string{
	0: "servicePrincipalId",
	1: "notificationGroupId",
}

// Decode decodes SakuraSimpleNotification from json.
func (s *SakuraSimpleNotification) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SakuraSimpleNotification to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "servicePrincipalId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ServicePrincipalId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servicePrincipalId\"")
			}
		case "notificationGroupId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.NotificationGroupId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"notificationGroupId\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SakuraSimpleNotification")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSakuraSimpleNotification) {
					name = jsonFieldsNameOfSakuraSimpleNotification[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SakuraSimpleNotification) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SakuraSimpleNotification) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *SakuraWorkflows) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *SakuraWorkflows) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("servicePrincipalId")
		e.Str(s.ServicePrincipalId)
	}
	{
		e.FieldStart("workflowId")
		e.Str(s.WorkflowId)
	}
	{
		if s.RevisionId.Set {
			e.FieldStart("revisionId")
			s.RevisionId.Encode(e)
		}
	}
	{
		if s.RevisionAlias.Set {
			e.FieldStart("revisionAlias")
			s.RevisionAlias.Encode(e)
		}
	}
	{
		if s.Args.Set {
			e.FieldStart("args")
			s.Args.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
}

var jsonFieldsNameOfSakuraWorkflows = [6]string{
	0: "servicePrincipalId",
	1: "workflowId",
	2: "revisionId",
	3: "revisionAlias",
	4: "args",
	5: "name",
}

// Decode decodes SakuraWorkflows from json.
func (s *SakuraWorkflows) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SakuraWorkflows to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "servicePrincipalId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.ServicePrincipalId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servicePrincipalId\"")
			}
		case "workflowId":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.WorkflowId = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"workflowId\"")
			}
		case "revisionId":
			if err := func() error {
				s.RevisionId.Reset()
				if err := s.RevisionId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revisionId\"")
			}
		case "revisionAlias":
			if err := func() error {
				s.RevisionAlias.Reset()
				if err := s.RevisionAlias.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"revisionAlias\"")
			}
		case "args":
			if err := func() error {
				s.Args.Reset()
				if err := s.Args.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"args\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SakuraWorkflows")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSakuraWorkflows) {
					name = jsonFieldsNameOfSakuraWorkflows[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *SakuraWorkflows) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SakuraWorkflows) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *ServerNoPublicIP) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *ServerNoPublicIP) encodeFields(e *jx.Encoder) {
	{
		e.FieldStart("evaluationRuleId")
		s.EvaluationRuleId.Encode(e)
	}
	{
		if s.Parameter.Set {
			e.FieldStart("parameter")
			s.Parameter.Encode(e)
		}
	}
}

var jsonFieldsNameOfServerNoPublicIP = [2]string{
	0: "evaluationRuleId",
	1: "parameter",
}

// Decode decodes ServerNoPublicIP from json.
func (s *ServerNoPublicIP) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerNoPublicIP to nil")
	}
	var requiredBitSet [1]uint8

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "evaluationRuleId":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				if err := s.EvaluationRuleId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"evaluationRuleId\"")
			}
		case "parameter":
			if err := func() error {
				s.Parameter.Reset()
				if err := s.Parameter.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameter\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode ServerNoPublicIP")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfServerNoPublicIP) {
					name = jsonFieldsNameOfServerNoPublicIP[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *ServerNoPublicIP) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerNoPublicIP) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes ServerNoPublicIPEvaluationRuleId as json.
func (s ServerNoPublicIPEvaluationRuleId) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes ServerNoPublicIPEvaluationRuleId from json.
func (s *ServerNoPublicIPEvaluationRuleId) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode ServerNoPublicIPEvaluationRuleId to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch ServerNoPublicIPEvaluationRuleId(v) {
	case ServerNoPublicIPEvaluationRuleIdServerNoPublicIP:
		*s = ServerNoPublicIPEvaluationRuleIdServerNoPublicIP
	default:
		*s = ServerNoPublicIPEvaluationRuleId(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s ServerNoPublicIPEvaluationRuleId) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *ServerNoPublicIPEvaluationRuleId) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *TooManyRequests) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *TooManyRequests) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("instance")
			s.Instance.Encode(e)
		}
	}
}

var jsonFieldsNameOfTooManyRequests = [5]string{
	0: "type",
	1: "title",
	2: "status",
	3: "detail",
	4: "instance",
}

// Decode decodes TooManyRequests from json.
func (s *TooManyRequests) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TooManyRequests to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode TooManyRequests")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *TooManyRequests) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TooManyRequests) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TooManyRequestsDetail as json.
func (s TooManyRequestsDetail) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes TooManyRequestsDetail from json.
func (s *TooManyRequestsDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TooManyRequestsDetail to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch TooManyRequestsDetail(v) {
	case TooManyRequestsDetailTooManyRequests:
		*s = TooManyRequestsDetailTooManyRequests
	default:
		*s = TooManyRequestsDetail(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TooManyRequestsDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TooManyRequestsDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes TooManyRequestsStatus as json.
func (s TooManyRequestsStatus) Encode(e *jx.Encoder) {
	e.Float64(float64(s))
}

// Decode decodes TooManyRequestsStatus from json.
func (s *TooManyRequestsStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode TooManyRequestsStatus to nil")
	}
	v, err := d.Float64()
	if err != nil {
		return err
	}
	*s = TooManyRequestsStatus(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s TooManyRequestsStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *TooManyRequestsStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *Unauthorized) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *Unauthorized) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("instance")
			s.Instance.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnauthorized = [5]string{
	0: "type",
	1: "title",
	2: "status",
	3: "detail",
	4: "instance",
}

// Decode decodes Unauthorized from json.
func (s *Unauthorized) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Unauthorized to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Unauthorized")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *Unauthorized) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Unauthorized) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnauthorizedDetail as json.
func (s UnauthorizedDetail) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes UnauthorizedDetail from json.
func (s *UnauthorizedDetail) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnauthorizedDetail to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch UnauthorizedDetail(v) {
	case UnauthorizedDetailAuthenticationFailed:
		*s = UnauthorizedDetailAuthenticationFailed
	default:
		*s = UnauthorizedDetail(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnauthorizedDetail) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnauthorizedDetail) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes UnauthorizedStatus as json.
func (s UnauthorizedStatus) Encode(e *jx.Encoder) {
	e.Float64(float64(s))
}

// Decode decodes UnauthorizedStatus from json.
func (s *UnauthorizedStatus) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnauthorizedStatus to nil")
	}
	v, err := d.Float64()
	if err != nil {
		return err
	}
	*s = UnauthorizedStatus(v)

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s UnauthorizedStatus) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnauthorizedStatus) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s *UnexpectedError) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s *UnexpectedError) encodeFields(e *jx.Encoder) {
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.Status.Set {
			e.FieldStart("status")
			s.Status.Encode(e)
		}
	}
	{
		if s.Detail.Set {
			e.FieldStart("detail")
			s.Detail.Encode(e)
		}
	}
	{
		if s.Instance.Set {
			e.FieldStart("instance")
			s.Instance.Encode(e)
		}
	}
}

var jsonFieldsNameOfUnexpectedError = [5]string{
	0: "type",
	1: "title",
	2: "status",
	3: "detail",
	4: "instance",
}

// Decode decodes UnexpectedError from json.
func (s *UnexpectedError) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode UnexpectedError to nil")
	}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "status":
			if err := func() error {
				s.Status.Reset()
				if err := s.Status.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"status\"")
			}
		case "detail":
			if err := func() error {
				s.Detail.Reset()
				if err := s.Detail.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"detail\"")
			}
		case "instance":
			if err := func() error {
				s.Instance.Reset()
				if err := s.Instance.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"instance\"")
			}
		default:
			return d.Skip()
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode UnexpectedError")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s *UnexpectedError) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *UnexpectedError) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}
