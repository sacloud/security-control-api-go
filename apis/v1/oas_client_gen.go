// Code generated by ogen, DO NOT EDIT.

package v1

import (
	"context"
	"net/url"
	"strings"

	"github.com/go-faster/errors"
	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/uri"
)

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AutomatedActionsCreate invokes AutomatedActions_create operation.
	//
	// 新しい自動アクションを作成する。.
	//
	// POST /automated_actions
	AutomatedActionsCreate(ctx context.Context, request *AutomatedActionInput) (AutomatedActionsCreateRes, error)
	// AutomatedActionsDelete invokes AutomatedActions_delete operation.
	//
	// 指定されたIDの自動アクションを削除する。.
	//
	// DELETE /automated_actions/{actionId}
	AutomatedActionsDelete(ctx context.Context, params AutomatedActionsDeleteParams) (AutomatedActionsDeleteRes, error)
	// AutomatedActionsList invokes AutomatedActions_list operation.
	//
	// 自動アクションを一覧取得する。
	// pageSizeの最大値は100。100を超える値は100として扱う。
	// pageSize未指定時は50。.
	//
	// GET /automated_actions
	AutomatedActionsList(ctx context.Context, params AutomatedActionsListParams) (AutomatedActionsListRes, error)
	// AutomatedActionsRead invokes AutomatedActions_read operation.
	//
	// 指定されたIDの自動アクション詳細を取得する。.
	//
	// GET /automated_actions/{actionId}
	AutomatedActionsRead(ctx context.Context, params AutomatedActionsReadParams) (AutomatedActionsReadRes, error)
	// AutomatedActionsUpdate invokes AutomatedActions_update operation.
	//
	// 指定されたIDの自動アクションを更新する。.
	//
	// PUT /automated_actions/{actionId}
	AutomatedActionsUpdate(ctx context.Context, request *AutomatedActionInput, params AutomatedActionsUpdateParams) (AutomatedActionsUpdateRes, error)
	// EvaluationRulesList invokes EvaluationRules_list operation.
	//
	// プロジェクトの評価ルールを一覧取得する。
	// pageSizeの最大値は100。100を超える値は100として扱う。
	// pageSize未指定時は50。.
	//
	// GET /evaluation_rules
	EvaluationRulesList(ctx context.Context, params EvaluationRulesListParams) (EvaluationRulesListRes, error)
	// EvaluationRulesRead invokes EvaluationRules_read operation.
	//
	// 指定されたIDの評価ルール詳細を取得する。.
	//
	// GET /evaluation_rules/{evaluationRuleId}
	EvaluationRulesRead(ctx context.Context, params EvaluationRulesReadParams) (EvaluationRulesReadRes, error)
	// EvaluationRulesUpdate invokes EvaluationRules_update operation.
	//
	// 指定されたIDの評価ルールを更新する。.
	//
	// PUT /evaluation_rules/{evaluationRuleId}
	EvaluationRulesUpdate(ctx context.Context, request *EvaluationRuleInput, params EvaluationRulesUpdateParams) (EvaluationRulesUpdateRes, error)
	// ProjectActivationCreate invokes ProjectActivation_create operation.
	//
	// 現在のプロジェクトをセキュリティコントロールで有効化する（新規有効化状態を作成）。
	// 成功時は200、リクエストが不正な場合は400を返す。.
	//
	// POST /activation
	ProjectActivationCreate(ctx context.Context, request *ActivationCreateInput) (ProjectActivationCreateRes, error)
	// ProjectActivationRead invokes ProjectActivation_read operation.
	//
	// 現在のプロジェクトの有効化状態を取得する。
	// 成功時は200で有効化詳細を返し、プロジェクトがまだ一度も有効化されていない場合は404を返す。.
	//
	// GET /activation
	ProjectActivationRead(ctx context.Context) (ProjectActivationReadRes, error)
	// ProjectActivationUpdate invokes ProjectActivation_update operation.
	//
	// 現在のプロジェクトの有効化状態を更新する。
	// 成功時は200で更新後の有効化詳細を返し、リクエストが不正な場合は400を返す。.
	//
	// PUT /activation
	ProjectActivationUpdate(ctx context.Context, request *ActivationUpdateInput) (ProjectActivationUpdateRes, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AutomatedActionsCreate invokes AutomatedActions_create operation.
//
// 新しい自動アクションを作成する。.
//
// POST /automated_actions
func (c *Client) AutomatedActionsCreate(ctx context.Context, request *AutomatedActionInput) (AutomatedActionsCreateRes, error) {
	res, err := c.sendAutomatedActionsCreate(ctx, request)
	return res, err
}

func (c *Client) sendAutomatedActionsCreate(ctx context.Context, request *AutomatedActionInput) (res AutomatedActionsCreateRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/automated_actions"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAutomatedActionsCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBasicAuth(ctx, AutomatedActionsCreateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAutomatedActionsCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AutomatedActionsDelete invokes AutomatedActions_delete operation.
//
// 指定されたIDの自動アクションを削除する。.
//
// DELETE /automated_actions/{actionId}
func (c *Client) AutomatedActionsDelete(ctx context.Context, params AutomatedActionsDeleteParams) (AutomatedActionsDeleteRes, error) {
	res, err := c.sendAutomatedActionsDelete(ctx, params)
	return res, err
}

func (c *Client) sendAutomatedActionsDelete(ctx context.Context, params AutomatedActionsDeleteParams) (res AutomatedActionsDeleteRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/automated_actions/"
	{
		// Encode "actionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "actionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ActionId); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBasicAuth(ctx, AutomatedActionsDeleteOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAutomatedActionsDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AutomatedActionsList invokes AutomatedActions_list operation.
//
// 自動アクションを一覧取得する。
// pageSizeの最大値は100。100を超える値は100として扱う。
// pageSize未指定時は50。.
//
// GET /automated_actions
func (c *Client) AutomatedActionsList(ctx context.Context, params AutomatedActionsListParams) (AutomatedActionsListRes, error) {
	res, err := c.sendAutomatedActionsList(ctx, params)
	return res, err
}

func (c *Client) sendAutomatedActionsList(ctx context.Context, params AutomatedActionsListParams) (res AutomatedActionsListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/automated_actions"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Next.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "prev" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "prev",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Prev.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBasicAuth(ctx, AutomatedActionsListOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAutomatedActionsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AutomatedActionsRead invokes AutomatedActions_read operation.
//
// 指定されたIDの自動アクション詳細を取得する。.
//
// GET /automated_actions/{actionId}
func (c *Client) AutomatedActionsRead(ctx context.Context, params AutomatedActionsReadParams) (AutomatedActionsReadRes, error) {
	res, err := c.sendAutomatedActionsRead(ctx, params)
	return res, err
}

func (c *Client) sendAutomatedActionsRead(ctx context.Context, params AutomatedActionsReadParams) (res AutomatedActionsReadRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/automated_actions/"
	{
		// Encode "actionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "actionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ActionId); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBasicAuth(ctx, AutomatedActionsReadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAutomatedActionsReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// AutomatedActionsUpdate invokes AutomatedActions_update operation.
//
// 指定されたIDの自動アクションを更新する。.
//
// PUT /automated_actions/{actionId}
func (c *Client) AutomatedActionsUpdate(ctx context.Context, request *AutomatedActionInput, params AutomatedActionsUpdateParams) (AutomatedActionsUpdateRes, error) {
	res, err := c.sendAutomatedActionsUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendAutomatedActionsUpdate(ctx context.Context, request *AutomatedActionInput, params AutomatedActionsUpdateParams) (res AutomatedActionsUpdateRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/automated_actions/"
	{
		// Encode "actionId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "actionId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			if unwrapped := string(params.ActionId); true {
				return e.EncodeValue(conv.StringToString(unwrapped))
			}
			return nil
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeAutomatedActionsUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBasicAuth(ctx, AutomatedActionsUpdateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeAutomatedActionsUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EvaluationRulesList invokes EvaluationRules_list operation.
//
// プロジェクトの評価ルールを一覧取得する。
// pageSizeの最大値は100。100を超える値は100として扱う。
// pageSize未指定時は50。.
//
// GET /evaluation_rules
func (c *Client) EvaluationRulesList(ctx context.Context, params EvaluationRulesListParams) (EvaluationRulesListRes, error) {
	res, err := c.sendEvaluationRulesList(ctx, params)
	return res, err
}

func (c *Client) sendEvaluationRulesList(ctx context.Context, params EvaluationRulesListParams) (res EvaluationRulesListRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/evaluation_rules"
	uri.AddPathParts(u, pathParts[:]...)

	q := uri.NewQueryEncoder()
	{
		// Encode "page_size" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "page_size",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PageSize.Get(); ok {
				return e.EncodeValue(conv.IntToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "next" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "next",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Next.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "prev" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "prev",
			Style:   uri.QueryStyleForm,
			Explode: false,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Prev.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBasicAuth(ctx, EvaluationRulesListOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEvaluationRulesListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EvaluationRulesRead invokes EvaluationRules_read operation.
//
// 指定されたIDの評価ルール詳細を取得する。.
//
// GET /evaluation_rules/{evaluationRuleId}
func (c *Client) EvaluationRulesRead(ctx context.Context, params EvaluationRulesReadParams) (EvaluationRulesReadRes, error) {
	res, err := c.sendEvaluationRulesRead(ctx, params)
	return res, err
}

func (c *Client) sendEvaluationRulesRead(ctx context.Context, params EvaluationRulesReadParams) (res EvaluationRulesReadRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/evaluation_rules/"
	{
		// Encode "evaluationRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "evaluationRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.EvaluationRuleId)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBasicAuth(ctx, EvaluationRulesReadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEvaluationRulesReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// EvaluationRulesUpdate invokes EvaluationRules_update operation.
//
// 指定されたIDの評価ルールを更新する。.
//
// PUT /evaluation_rules/{evaluationRuleId}
func (c *Client) EvaluationRulesUpdate(ctx context.Context, request *EvaluationRuleInput, params EvaluationRulesUpdateParams) (EvaluationRulesUpdateRes, error) {
	res, err := c.sendEvaluationRulesUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendEvaluationRulesUpdate(ctx context.Context, request *EvaluationRuleInput, params EvaluationRulesUpdateParams) (res EvaluationRulesUpdateRes, err error) {
	// Validate request before sending.
	if err := func() error {
		if err := request.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return res, errors.Wrap(err, "validate")
	}

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/evaluation_rules/"
	{
		// Encode "evaluationRuleId" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "evaluationRuleId",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.StringToString(string(params.EvaluationRuleId)))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeEvaluationRulesUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBasicAuth(ctx, EvaluationRulesUpdateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeEvaluationRulesUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectActivationCreate invokes ProjectActivation_create operation.
//
// 現在のプロジェクトをセキュリティコントロールで有効化する（新規有効化状態を作成）。
// 成功時は200、リクエストが不正な場合は400を返す。.
//
// POST /activation
func (c *Client) ProjectActivationCreate(ctx context.Context, request *ActivationCreateInput) (ProjectActivationCreateRes, error) {
	res, err := c.sendProjectActivationCreate(ctx, request)
	return res, err
}

func (c *Client) sendProjectActivationCreate(ctx context.Context, request *ActivationCreateInput) (res ProjectActivationCreateRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/activation"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectActivationCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBasicAuth(ctx, ProjectActivationCreateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectActivationCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectActivationRead invokes ProjectActivation_read operation.
//
// 現在のプロジェクトの有効化状態を取得する。
// 成功時は200で有効化詳細を返し、プロジェクトがまだ一度も有効化されていない場合は404を返す。.
//
// GET /activation
func (c *Client) ProjectActivationRead(ctx context.Context) (ProjectActivationReadRes, error) {
	res, err := c.sendProjectActivationRead(ctx)
	return res, err
}

func (c *Client) sendProjectActivationRead(ctx context.Context) (res ProjectActivationReadRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/activation"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBasicAuth(ctx, ProjectActivationReadOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectActivationReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ProjectActivationUpdate invokes ProjectActivation_update operation.
//
// 現在のプロジェクトの有効化状態を更新する。
// 成功時は200で更新後の有効化詳細を返し、リクエストが不正な場合は400を返す。.
//
// PUT /activation
func (c *Client) ProjectActivationUpdate(ctx context.Context, request *ActivationUpdateInput) (ProjectActivationUpdateRes, error) {
	res, err := c.sendProjectActivationUpdate(ctx, request)
	return res, err
}

func (c *Client) sendProjectActivationUpdate(ctx context.Context, request *ActivationUpdateInput) (res ProjectActivationUpdateRes, err error) {

	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/activation"
	uri.AddPathParts(u, pathParts[:]...)

	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeProjectActivationUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{

			switch err := c.securityBasicAuth(ctx, ProjectActivationUpdateOperation, r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BasicAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	result, err := decodeProjectActivationUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
